<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[static关键字]]></title>
    <url>%2F2018%2F04%2F01%2Fstatic%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[static可以声明属性和方法 1.static定义属性：用static声明的变量，直接用类名调用（类名.变量）。1234567891011121314151617181920212223242526272829class Book&#123; private String name; private double price; static String pub = "清华大学出版社"; public Book(String name,double price) &#123; this.name = name; this.price = price; &#125; public String getInfo() &#123; return "书名:" + this.name + ",书的价格:" + this.price + ",出版社:" + this.pub; &#125;&#125;public class StaticDemo&#123; public static void main(String[] args) &#123; Book ba = new Book("java",98.0); Book bb = new Book("ios",88.7); Book bc = new Book("oracle",66.0); Book.pub = "北京大学出版社"; System.out.println(ba.getInfo()); System.out.println(bb.getInfo()); System.out.println(bc.getInfo()); &#125;&#125;---&gt;运行结果:书名:java,书的价格:98.0,出版社:北京大学出版社书名:ios,书的价格:88.7,出版社:北京大学出版社书名:oracle,书的价格:66.0,出版社:北京大学出版社 2.static定义方法: 直接用类.方法()调用。1234567891011121314151617181920212223242526272829303132class Book&#123; private String name; private double price; private static String pub = "清华大学出版社"; //设置静态私有属性 public Book(String name,double price) &#123; this.name = name; this.price = price; &#125; public static void setPub(String p) &#123; //设置静态set方法 pub = p; &#125; public String getInfo() &#123; return "书名:" + this.name + ",书的价格:" + this.price + ",出版社:" + this.pub; &#125;&#125;public class StaticDemo&#123; public static void main(String[] args) &#123; Book ba = new Book("java",98.0); Book bb = new Book("ios",88.7); Book bc = new Book("oracle",66.0); Book.setPub("北京大学出版社"); //直接用类.方法()调用 System.out.println(ba.getInfo()); System.out.println(bb.getInfo()); System.out.println(bc.getInfo()); &#125;&#125;----&gt;运行结果:书名:java,书的价格:98.0,出版社:北京大学出版社书名:ios,书的价格:88.7,出版社:北京大学出版社书名:oracle,书的价格:66.0,出版社:北京大学出版社 总结： ①：static方法只能调用static属性和方法;123456789public class StaticDemo&#123; public static void main(String[] args) &#123; fun(); &#125; public static void fun() &#123; System.out.println("Hello World"); &#125;&#125;---&gt;Hello World ②：非static方法不受任何限制；123456789public class StaticDemo&#123; public static void main(String[] args) &#123; fun(); &#125; public void fun() &#123; System.out.println("Hello World"); &#125;&#125;---&gt;错误: 无法从静态上下文中引用非静态 方法 fun() 改进———————-&gt; 所有的非static方法必须由对象调用，因此static方法如果要想使用非static操作，必须产生对象才能调用123456789public class StaticDemo&#123; public static void main(String[] args) &#123; new StaticDemo().fun(); //匿名对象调用 &#125; public void fun() &#123; System.out.println("Hello World"); &#125;&#125;---&gt;Hello World]]></content>
      <categories>
        <category>java</category>
        <category>java面向对象</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this关键字]]></title>
    <url>%2F2018%2F04%2F01%2Fthis%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[使用this关键字可以实现类属性的调用，类方法（普通方法，构造方法）的调用，表示当前对象。 本次笔记只实现前两项的内容：1.this调用属性例：观察如下代码：1234567891011121314151617181920class Book&#123; private String name; private double price; public Book(String name,double price) &#123; this.name = name; //this调用属性 this.price = price; &#125; public String getInfo() &#123; return "书名:" + this.name + ",书的价格:" + this.price; //访问类中的属性，必须加上this &#125;&#125;public class ThisDemo&#123; public static void main(String[] args) &#123; Book book = new Book("java",67.9); System.out.println(book.getInfo()); &#125;&#125;----&gt;书名:java,书的价格:67.9 2.this调用普通方法12345678910111213141516171819202122232425262728class Book&#123; private String name; private double price; public Book(String name,double price) &#123; this.name = name; this.price = price; &#125; public void print() &#123; System.out.println("=========="); &#125; public String getInfo() &#123; this.print(); //this调用普通方法 return "书名:" + this.name + ",书的价格:" + this.price; &#125;&#125;public class ThisDemo&#123; public static void main(String[] args) &#123; Book book = new Book("java",67.9); System.out.println(book.getInfo()); &#125;&#125;----&gt;运行结果:==========书名:java,书的价格:67.9 3.this调用构造方法1234567891011121314151617181920212223242526272829303132class Book&#123; private String name; private double price; public Book() &#123; System.out.println("一个新的Book类产生"); &#125; public Book(String name) &#123; this(); //调用本类的无参构造 this.name = name; &#125; public Book(String name,double price) &#123; this(name); //调用本类的单参构造 this.price = price; &#125; public String getInfo() &#123; return "书名:" + this.name + ",书的价格:" + this.price; &#125;&#125;public class ThisDemo&#123; public static void main(String[] args) &#123; Book book = new Book("java",67.9); System.out.println(book.getInfo()); &#125;&#125;----&gt;运行结果:一个新的Book类产生书名:java,书的价格:67.9 4.实例：定义一个雇员类（编号，姓名，工资，部门）,在这个类里面提供四个构造方法； 无参构造:编号为0；姓名为无名氏，工资为0.0，部门设置为“未定”;单参构造（传递编号）：姓名为：临时工，工资为：800.0，部门为后勤；双参构造（传递编号，姓名）：工资为2000.0，部门为技术部；四参构造；123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Emp&#123; private int empno; private String ename; private double sal; private String dept; public Emp() &#123; //无参构造 this(0,"无名氏",0.0,"未定"); &#125; public Emp(int empno) &#123; //单参构造 this(empno,"临时工", 800.0,"后勤"); &#125; public Emp(int empno,String ename) &#123; //双参构造 this(empno,ename,2000.0,"技术部"); &#125; public Emp(int empno,String ename,double sal,String dept) &#123; //四参构造 this.empno = empno; this.ename = ename; this.sal = sal; this.dept = dept; &#125; public String getInfo() &#123; return "雇员编号:" + this.empno + ",雇员姓名:" + this.ename + ",雇员工资:" + this.sal + ",雇员部门:" + this.dept; &#125;&#125;public class ThisDemo&#123; public static void main(String[] args) &#123; Emp ea = new Emp(); Emp eb = new Emp(1); Emp ec = new Emp(2,"张三"); Emp ed = new Emp(3,"李四",900.0,"财务部"); System.out.println(ea.getInfo()); System.out.println(eb.getInfo()); System.out.println(ec.getInfo()); System.out.println(ed.getInfo()); &#125;&#125;----&gt;运行结果：雇员编号:0,雇员姓名:无名氏,雇员工资:0.0,雇员部门:未定雇员编号:1,雇员姓名:临时工,雇员工资:800.0,雇员部门:后勤雇员编号:2,雇员姓名:张三,雇员工资:2000.0,雇员部门:技术部雇员编号:3,雇员姓名:李四,雇员工资:900.0,雇员部门:财务部]]></content>
      <categories>
        <category>java</category>
        <category>java面向对象</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String类基本]]></title>
    <url>%2F2018%2F03%2F23%2FString%E7%B1%BB%E5%9F%BA%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[String 类的基本特点1.String有两种实例化方式，一种是通过直接赋值的方式，另一种是通过new关键字调用构造方法来进行实例化。例①：直接采用赋值处理 必须明确一个重要的概念，一个字符串就是一个String类的匿名对象1234567public class StringDemo &#123; public static void main(String[] args) &#123; String str = "hello"; //str是一个对象，因此"hello"就保存在堆内存之中,hello就是一个匿名对象 System.out.println(str); &#125;&#125; 例②：通过关键字new调用构造方法 String类提供了大量构造方法来创建String对象，首先看如下构造方法：public String(String name)1234567public class StringDemo &#123; public static void main(String[] args) &#123; String str = new String("hello"); //该过程符合于传统做法，有类之后遇到关键字new进行对象实例化 System.out.println(str); &#125;&#125; 2.字符串相等比较1)数值比较例①：观察基本数据类型比较12345678public class StringDemo &#123; public static void main(String[] args) &#123; int x = 10; int y = 10; System.out.println(x==y); &#125;&#125; ---&gt;结果为true 例②：观察在String类的对象上使用“==”12345678public class StringDemo &#123; public static void main(String[] args) &#123; String str1 = "hello"; String str2 = new String("hello"); System.out.println(str1==str2); &#125;&#125; ---&gt;结果为false 如上代码可以看出，两个字符串的内容是相同的，而使用“==”比较后运行结果为false。why？ 内存图： 由上面的内存图可以看出，”==”本身进行的是数值的比较（内存地址） 2)内容比较 要进行内容的比较，需要使用String类中提供的equals方法内容比较：public boolean equals(String str) 例：字符串内容的比较12345678public class StringDemo &#123; public static void main(String[] args) &#123; String str1 = "hello"; String str2 = new String("hello"); System.out.println(str1.equals(str2)); &#125;&#125;---&gt;true 3.字符串类是String类的匿名对象 java里面本身没有提供字符串常量的概念，所有使用“”定义的内容本质上都是String类的匿名对象 例①：观察字符串的操作12345678public class StringDemo &#123; public static void main(String[] args) &#123; String str = "hello"; System.out.println("hello".equals(str)); System.out.println(str.equals("hello")); &#125;&#125;---&gt;true true “hello”,本质上就是匿名对象,存在堆内存之中 例②：两种方式的比较（推荐写法方式二） 注：如果要判断用户输入的字符串是否等同于指定的字符串，一定要将字符串写在前面。 方式一：1234567public class StringDemo &#123; public static void main(String[] args) &#123; String str = null; System.out.println(str.equals("hello")); &#125;&#125;---&gt;NullpointerException 在进行输入数据接收的时候必须考虑到用户没有输入数据的问题，以上的代码为：用户没有输入，则执行的时候一定会出现NullpointerException问题 方式二：(将字符串写在前面) 任何的字符串常量都是String类的匿名对象，所以该对象永远不可能为空1234567public class StringDemo &#123; public static void main(String[] args) &#123; String str = null; System.out.println("hello".equals(str)); //hello为匿名对象 &#125;&#125;---&gt;false 4.String类两种对象实例化的区别1).采用直接赋值1)Demo01123public static void main(String[] args) &#123; String str = "hello";&#125; 内存图： 2)Demo02123456789101112public class StringDemo &#123; public static void main(String[] args) &#123; String str1 = "hello"; String str2 = "hello"; String str3 = "hello"; System.out.println(str1 == str2); System.out.println(str2 == str3); System.out.println(str1 == str3); &#125;&#125;---&gt;true true ture 内存图： 为什么没有开辟新的堆内存空间？ 这种方式的实现原理在java中称为共享设计。这种设计的思路是，在java中形成一个对象池，在这个对象池中保存多个对象，新实例化的对象如果已经在池中定义了，则不再重新定义，而从池中直接取出继续使用。String就是因为采用了这样的设计，所以当内容重复时，会将对象指向已存在的实例空间，直接进行引用；如果没有，则开辟新的字符串对象，将其保存在对象池之中以供下次使用（对象池就是一个对象数组）。 2）采用构造方法1String str = new String("hello"); 内存图： 分析：①括号优先级最高，“hello”最早执行，它是字符串匿名对象②new：开辟新的堆内存空间如果使用了构造方法，将会开辟两块堆内存空间，并且其中有一块堆内存空间会成为垃圾空间 例：观察字符串共享问题12345678public class StringDemo &#123; public static void main(String[] args) &#123; String str1 = new String("hello"); //代码运行结果为false，说明字符串常量并没有保存在对象池中 String str2 = "hello"; System.out.println(str1 == str2); &#125;&#125;---&gt;false String类中有一个方法可以实现入池的操作。public String intern()12345678public class StringDemo &#123; public static void main(String[] args) &#123; String str1 = new String("hello").intern(); //new String()为一个匿名对象，因此可以直接调用方法。 String str2 = "hello"; System.out.println(str1 == str2); &#125;&#125;---&gt;true 直接赋值：只会开辟一块堆内存空间，字符串的内容可以自动入池，以供下次使用。构造方法：会开辟两块堆内存空间；即①“xxx”匿名对象，和②new创建的对象，“xxx”会直接成为垃圾，构造方法赋值不会入池。需要手工入池，利用intern() 5.字符串一旦定义则不可改变 注：字符串的底层实现都是字符串组 例：观察如下代码内存图： 分析内存图：字符串没有任何变化，字符串对象引用却一直在改变，因此会产生大量的垃圾，要避免这样的操作。]]></content>
      <categories>
        <category>java</category>
        <category>java面向对象</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构造方法]]></title>
    <url>%2F2018%2F03%2F20%2F%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[构造方法与匿名对象1.实例化对象的产生格式： 类名称 对象名称 = new 类名称（）；类名称：任何的对象都应该有其对应的类对象名称：类的一个实例new：表示开辟新的堆内存空间类名称（）：构造方法 解析：构造器是一个类创建对象的根本途径，java语言通过new关键字来调用构造器，从而返回一个该类的实例。 2.构造方法用法：123public Car() &#123; //(无参数，无返回值)&#125; 3.构造方法定义的规则： ①通过new来调用；②不用定义返回值类型；③构造方法的方法名称必须与类名称一致；④如果不加构造方法，系统会自动加一个无参的构造方法；如果已经写了构造方法，系统将不会为该类提供构造方法； 4.例①：定义一个无参的构造方法（构造方法在new时被调用）在前面写的person类中添加一个无参的构造函数，然后运行看一下运行结果123public Person() &#123; System.out.println("*********");&#125; *********name=小明,age=20 先执行无参构造函数中的，说明构造函数在new时被调用 5.例②：类中定义一个有参构造函数123456789101112131415161718192021222324252627282930313233343536class Person &#123; private String name; private int age; public Person() &#123; System.out.println("*********"); &#125; public Person(String n,int a) &#123; name = n; setAge(a); &#125; public void setName(String n) &#123; name = n; &#125; public void setAge(int a) &#123; age = a; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; public void info() &#123; System.out.println("name=" + name + ",age=" + age); &#125;&#125;public class TestDemo &#123; public static void main(String[] args) &#123; Person per = new Person("小明",20); per.info(); &#125;&#125; 注：定义有参构造函数以后，默认的无参构造函数将不会在编译时自动生成。 类中的组成：属性，普通方法，构造方法属性在对象开辟堆内存的时候开辟的空间构造方法在使用关键字new同时调用普通方法在对象已经实例化完成（即空间开辟了，构造方法执行了）再调用，可以调用多次。 6.构造方法作用： 1）构造该类的对象，通常用来初始化对象的属性。2）构造方法是方法可以进行重载，只能实现参数的类型或个数不同这一特点。 以上例②的代码就是构成了构造方法的重载。 类定义的基本要求：①属性②构造方法③普通方法构造方法要按照参数的个数升序或降序排列。 7.匿名对象 匿名对象的应用场景 A:调用方法，仅仅只调用一次的时候 B:匿名对象可以作为实际参数传递 1如：new Person("张三",30).info(); 匿名对象不会有任何的栈空间所指向，匿名对象调用一次之后就是垃圾，可以被垃圾回收器回收 。]]></content>
      <categories>
        <category>java</category>
        <category>java面向对象</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[private关键字]]></title>
    <url>%2F2018%2F03%2F20%2Fprivate%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[面向对象的三大特征：封装，继承，多态。 1.定义：封装，将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象的内部信息，通过该类所提供的方法来实现对内部信息的操作和访问。 2.封装的访问操作符—&gt;privateprivate实现封装处理：(内部的操作对外部不可见，该成员只能在当前类的内部被访问)①例：利用private来实现封装1234class Person &#123; private String name; private int age; &#125; 注：该类的name和age两个成员变量只能在Person类内才可以操作和访问，在Person类之外，则要通过各自对应的setter和getter方法来操作和访问。 3.setter,getter方法 setter方法：主要是用于属性内容的设置。getter方法：主要是用于属性内容的取得。用法： getter方法：必须有返回类型，且和要访问的私有属性类型一致。必须有返回语句，返回要访问的私有属性。setter方法：必须要有参数，且参数类型要和访问的私有属性类型一致，返回类型为void，要有赋值语句。 ②例：person类添加setter，getter方法12345678910111213141516171819202122232425262728class Person &#123; private String name; private int age; public void setName(String n) &#123; name = n; &#125; public void setAge(int a) &#123; age = a; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; public void info() &#123; System.out.println("name=" + name + ",age=" + age); &#125;&#125;public class TestDemo &#123; public static void main(String[] args) &#123; Person per = new Person(); per.setName("小明"); per.setAge(20); per.info(); &#125;&#125; 类的设计原则： 1）类中的所有属性必须使用private进行封装，使用private封装的属性如果需要被外部所使用，就需要写相应的setter或getter方法。2）private实现封装的最大特点：只允许本类访问，不允许外部访问。]]></content>
      <categories>
        <category>java</category>
        <category>java面向对象</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象和类]]></title>
    <url>%2F2018%2F03%2F19%2F%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[1.对象1）定义：对象是一个具体存在的实体。如我们日常所说的人，是人的实例，而不是人类。2）对象可以分为两部分：动态部分，静态部分。 ①静态部分，指的是不能动的部分，称之为属性。（如，一个人的高矮，胖瘦，年龄，性别）②动态部分，指的是事物所具备的动态行为，称为行为。（如，一个人可以哭，微笑，说话，走路等） 3）设计一个大雁对象 2.类（要求：类名称首字母大写）1）类是封装对象属性和行为的载体，用于描述客观世界某一类对象的共同特征。2）类指的是一个共性的概念，对象指的是一个具体的可以使用的事物。一定是先产生类，在产生对象。3）类中的组成：方法（操作的行为），属性（变量，描述每一个对象的具体特点）。4）类的定义： 1234567class &#123; 属性； 属性； …… 方法()； 方法();&#125; 注：所有的程序都要求以{}作为分隔符 5）例：定义一个Person类 12345678class Person&#123; String name; //定义name属性 int age; //定义age属性 public void info() &#123; //定义一个info方法 System.out.println("name=" + name + ",age=" + age); &#125;&#125; 类定义之后不可以直接使用，必须声明并实例化对象 123456789public class TestDemo &#123; public static void main(String[] args) &#123; Person per = new Person(); //声明实例化对象per per.name = "feifei"; //对象.属性 per.age = 22; //对象.属性 per.info(); //对象.方法 &#125;&#125; 3.引用类型 定义：类可以当成自定义类型，也可以用类来定义变量，这种类型的变量称为引用变量。即类是引用类型。 引用类型占两块内存，看如下：内存空间分为两种：①堆内存空间：保存真正的数据，即保存对象的属性信息。②栈内存空间：保存堆内存的地址，即保存对象的名称。new：开辟新的堆内存。 内存图:（一个栈只能存一个堆内存地址） 4.对象的产生对象的产生有两种格式：1）先声明，再实例化；2）直接用new创建对象12①Person p = null; p = new Person();②Person p = new Person(); 1 所有的引用数据类型（数组，类，接口）必须在其开辟空间之后才能使用，如果使用了未开辟空间的数据类型会出现NullPointerException（对象没有实例化）2 引用数据类型的最大特征在于内存的分配操作，出现关键词new即：开辟堆内存3 所有的对象只有实例化以后才可以使用]]></content>
      <categories>
        <category>java</category>
        <category>java面向对象</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表的创建与管理]]></title>
    <url>%2F2018%2F03%2F11%2F%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[1.常见的数据类型(四种)数据表属于各种类型的一个集合 （oracle特有的）varchar(n)：表示字符串，其中n表示最大的长度，一般保存长度比较小的类型number(n,m)：number(n):表示整数数据，最多不能超过n个长度，可以使用int floatnumber(n,m)：表示小数点占m位，整数位占n-m位 date：表示保存的日期时间数据clob：表示大文本数据，最多可以保存4G的文字，可以保存《红楼梦》（现在不常用）blob：表示二进制数据，最多可以保存4G的内容，可以保存文字，图片，音乐，电影。 2.表的创建创建一个如下的成员表①创建此member表 1create table member (mid number(5),name varchar2(50) default '无名氏',arg number(3),birthday date default sysdate,note clob); ②查看member表结构 1desc member； ③向member表中增加若干条测试数据 1insert into member(mid,name,arg,birthday,note) values(1,'feifei',21,to_date('1997-07-09','yyyy-mm-dd'),'员工'); 1select * from member; 3.数据表的重命名 数据字典：（数据对象一定在数据字典中）①用户级别：user*开头，指的是一个用户可以使用的数据字典②管理员级别：dba开头，指的是由数据管理员使用的数据字典③全部级别：all_开头，表示不管是用户还是管理员都可以使用 将member表修改为mlueer表 1rename member to mluser; 1select * from mluser; 4.截断表截断mluser表 1truncate table mluser; 执行完此命令后，mluser表中的数据被清空，所有的资源也被删除，剩下的只是一张空的mluser表 注：开发中使用的清空操作一共有两种： delete from 表名称——清空数据 truncate table 表名称——截断表截断表是oracle数据库特有的，在开发中使用清空数据是很危险的操作，最好不要使用 5.表的删除删除myemp表 1drop table myemp; 注：表的创建和删除属于DDL操作 6.修改表结构 在DDL定义中，对于数据库对象的操作主要有3种语法：创建对象：create 对象类型 名称……删除对象：drop 对象类型 名称……修改对象：alter 对象类型 名称…… 定义数据库创建脚本1）.删除数据表 1drop table member purge; 2）.创建数据表 1create table member(mid number,name varchar2(50)); 3）.测试数据 12insert into member(mid,name) values(10,'张三');insert into member(mid,name) values(20,'李四'); 4）.事务提交 12commit；select * from member; 运行后的结果：7.为表中增加数据字段向member表中增加三个数据字段 123alter table member add(age number(3));alter table member add(sex varchar2(10) default '男');alter table member add(photo varchar2(100) default 'nophoto.jpg'); 查看member表结构 1desc member； 1select * from member; 8.修改表中的字段将name字段的长度修改为30，将sex字段的默认值修改为女 12alter table member modify(name varchar2(30));alter table member modify(sex varchar2(3) default '女'); 9.删除表中的字段删除member表中的photo和age字段 12alter table member drop column photo;alter table member drop column age; 总结：1.数据库中常见的数据类型为NUMBER,VARCHAR2,DATE,CLOB2.表的创建使用CREATE TABLE语法完成，创建表时需要为表中定义若干个列，每个列可以通过DEFAULT 设置列的默认值3.表的删除操作使用DROP TABLE语法来完成，但是从Oracle 10g开始，如果要彻底删除表，则应该加上PURGE配置4.通过截断表操作可以立即释放表中所占用的全部资源]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更新及事务处理]]></title>
    <url>%2F2018%2F03%2F11%2F%E6%9B%B4%E6%96%B0%E5%8F%8A%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[1.表的复制复制emp表——新的表名称为myemp 1create table myemp as select * from emp; 2.查看c##scott用户的全部表 123set line 300;set pages 30;select * from tab; 3.查询myemp表中是否存在数据 1select * from myemp; 4.数据的增加操作向myemp数据表中增加一条新的数据推荐的写法： 1insert into myemp(empno,job,hiredate,ename,mgr,sal,comm,deptno) values(8888,'CLERK',SYSDATE,'feiei',7369,800,100,20); 查询myemp表中的全部记录 1select * from myemp; 5.增加一个没有领导，没有部门，没有奖金的新雇员 1insert into myemp(empno,ename,job,hiredate,sal) values(6612,'小鑫','CLERK',to_date('1989-09-19','yyyy-mm-dd'),600); 1select * from myemp; 6.查询myemp表中是否存在编号为6612,8888的信息 1select * from myemp where empno in(6612,8888); 7.增加子查询结果数据将20部门雇员的信息插入到myemp表中 1insert into myemp select * from emp where deptno=20; 1select * from myemp; 8.数据的更新操作将SMITH（雇员编号为7369）的工资改为3000，并且每个月有500元的奖金 1update myemp set sal=3000,comm=500 where empno=7369; 1select * from myemp where deptno=7369; 9.将工资低于公司平均薪金的雇员的基本工资上涨10% 1update myemp set sal=sal*1.1; 10.使用已有数据更新数据表将雇员7369的职位，基本工资，雇佣日期更新为与7839相同的信息 1update myemp set(job,sal,hiredate)=(select job,sal,hiredate from myemp where empno=7839) where empno=7369; 1select * from myemp where empno in(7369,7839); 11.数据的删除操作删除雇员编号为7566的雇员信息 1delete from myemp where empno=7566; 12.删除30部门内的所有雇员 1delete from myemp where deptno=30; 13.删除编号为7369,7566,7788的雇员信息 1delete from myemp where empno in(7369,7566,7788); 14.删除所有在1987年雇佣的员工 1delete from myemp where to_char(hiredate,'yyyy')=1987; 15.删除公司工资最高的雇员 1delete from myemp where sal=(select max(sal) from myemp); 16.事务处理 事务是针对于数据更新使用的，也就是说只有DML的更新操作才存在有事务的支持session（会话，只要是此概念都表示唯一的一个登录用户），在oracle之中每一个登录到数据库上的用户都会自动的分配一个session。即：每一个session都表示不同的用户，而每一个session上都有独立的事务处理操作。每一个session的事务处理上都可以。 使用两个命令： commit：事务提交。即，如果已经执行了多条更新操作，那么只有执行了commit之后更新才会真正的发出，在没有执行commit之前，所有的更新操作都会保存在缓冲区之中。rollback：事务回滚操作。即，如果发现更新的操作有问题，则回复所有的更新操作，以保证原始数据不被破坏。]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部分总结一]]></title>
    <url>%2F2018%2F03%2F10%2F%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93%E4%B8%80%2F</url>
    <content type="text"><![CDATA[SQL语句基本分为如下4类： 1.DML：基本的增，删，改，查。2.DDL：主要用于完成数据库对象的创建和管理。create table，alter index3.DCL：主要用于权限管理4.TCL：主要用于控制事务的提交和回滚。commit，rollback 简单查询1.列出表定义为了查看表或视图的列定义，显示表结构，可以使用describe（可以简写为desc）命令 1例：desc dept； 2.由于SQL和PL/SQL的关键字不能缩写，但是SQL*plus命令可以缩写。通过设置列名称显示格式，输出数据 1例：col ename format A10； 1select enamel from emp where empno=7788； 3.查询时期列①以简体中文显示日期 1alter session set nls_date_language='simplified chinese'; 1select ename,hiredate from emp; ②以美国英语显示日期 1alter session set nls_date_language='American'; 1select ename,hiredate from emp; ③以特定格式显示日期 1alter session set nls_date_format='YYYY"年"MM"月"DD"日"'; 1select ename,hiredate from emp; ④使用to_char函数定制日期显示格式 1select ename,to_char(hiredate,'yyyy-mm-dd') 修改之后的日期 from emp; 4.排除重复行 distinct 1select distinct deptno,job from emp; 5.使用算术运算符 1select ename,sal,sal*12 from emp; 6.使用通用函数处理NULL①使用NVL函数处理NULL当算术表达式包含NULL时，如果不处理NULL,那么显示结果为空 1如：select ename,sal,comm,sal+comm from emp; 观察以上的显示结果，雇员的实发工资为空，显然不能符合应用的实际需求，为了避免出现此类情况，处理NULL使用NVL函数。 1select ename,sal,comm,sal+nvl(comm,0) from emp; ②使用NVL2函数处理NULL显示雇员名，工资，补助，以及实发工资 1select ename,sal,comm,nvl2(comm,sal+comm,sal) from emp; 7.使用别名 注意：使用的别名中如果有空格等特殊字符，一定要使用上双引号 1select ename "NAME",sal*12 "Annual Salary" from emp; 限制查询 为了根据特定条件检索数据，必须在select语句中使用where子句 1.where子句中使用like操作符1）通配符%：用于表示0个或多个字符显示以大写S开头的雇员名以及工资 1select ename,sal from emp where ename like 'S%'; 2）通配符_表示单个字符显示第三个字符为大写A的雇员名及工资 1select ename,sal from emp where ename like '__A%'; 2.where子句中使用IN操作符显示岗位CLERK和MANAGER的雇员名，工资和岗位 1select ename,sal,job from emp where job in('CLERK','MANAGER'); 3.在where子句中使用IS NULL操作符 1select ename from emp where mgr is null; 注：在使用null进行比较的时候不要使用=，&lt;&gt;操作符如：select ename,mgr from emp where mgr=null;运行结果为：未选定行 4.在where子句中使用and操作符显示部门20岗位CLERK的雇员名，工资，岗位以及部门号 1select ename,sal,job,deptno from emp where deptno=20 and job='CLERK'; 5.where子句中使用or操作符显示工资高于2500或者岗位为MANAGER的雇员名，工资，岗位以及部门名 1select ename,sal,job,deptno from emp where sal&gt;2500 or job='MANAGER'; 6.where子句中使用not操作符显示补助非空的所有雇员信息 1select * from emp where comm is not null; 7.where子句中混合使用逻辑操作符显示岗位CLERK 和 MANAGER，工资高于1000并低于3000的雇员名，工资，岗位。 1select ename,sal,job from emp where job in('CLERK','MANAGER') and sal between 1000 and 3000; 排序数据1.以工资升序显示所有雇员名以及工资 12select ename,sal from emp order by sal asc;select ename,sal from emp order by sal； 2.以工资降序显示雇员名以及工资 1select ename,sal from emp order by sal desc; 3.以降序显示雇员全年工资 1select ename,sal*12 全年工资 from emp order by 全年工资 desc; 4.以部门号升序 工资降序显示雇员名，部门号和工资 1select ename,deptno,sal from emp order by deptno asc,sal desc; 总结：1.检索所有列时，使用*，检索特定列时，需要指定列名，并且列之间使用逗号隔开。2.为避免null结果，使用NVL,NVL2函数处理NULL行3.当与NULL进行比较的时候，必须使用is null或is not null4.order by必须是最后一条子句 执行升序排列null行显示在最后面 执行降序排序null行显示在最前面5.进行排序的时候，首先基于order by子句的第一列进行排序，如果第一个列的值相同，才会基于第二列排序 数字函数1.round(n,[m])用于返回四舍五入的结果 n可以是任意数字，m必须为整数 ①如果省略m，则四舍五入到整数位 ②如果m为负数，则四舍五入到小数点前第m位③如果m为正数，则四舍五入到小数点后第m位 显示部门20所有雇员的工资总和和平均工资（四舍五入） 1select sum(sal),round(avg(sal)) from emp where deptno=20; 2.trunc(n,[m])用于截取数字 m必须为正数，n可以为任意数字 ①如果省略数字m，则将数字n的小数部分截取 ②如果数字m为正数，则数字n截取到小数点后第m位③如果数字m是负数，则将数字n截取至小数点前第m位 显示部门20所有雇员的工资总和和平均工资（截取至小数点后一位）select sum(sal),trunc(avg(sal),1) from emp where deptno=20;3.mod(m,n)取余显示部门10的所有雇员名，工资以及工资除以1000之后的余数 1select ename,sal,mod(sal,1000) from emp where deptno=10; 字符函数1.upper(char):将字符串转换成大写格式显示雇员SMITH的编码，工资和岗位，以大写为例 1select empno,sal,job from emp where upper(ename)='SMITH'; 2.lower(char)：将字符串转换为小写格式3.initcap(char):将字符串每个单词的首字符大写，其他小写4.substr(char,m[,n]):char用于指定源字符串，m用于指定子串起始位置，n用于指定子串长度 1select substr('Great Wall in china',7,30) from dual; 日期时间函数1.Sysdate：用于返回当前系统日期2.add_months(d,n):用于返回特定日期时间之后或之前的月份所对应的日期时间 d用于指定日期时间数据 n可以为任意整数 显示20部门所有雇员名称，以及工作20周年之后所对应的日期 1select ename,add_months(hiredate,20*12) "20周年" from emp where deptno=20; 3.months_between(d1,d2):用于返回日期d1和d2之间相差的月数显示部门10所有雇员的名称以及工作年份select ename,trunc(months_between(sysdate,hiredate)/12) work_year from emp where deptno=10;4.next_day(d,char):用于返回特定日期之后的第一个工作日所对应的日期 d指定日期时间值，char指定工作日注：当使用此函数时，工作日必须与日期语言匹配例：日期语言为American，周五对应为Friday日期语言为简体中文，周五对应为“星期五” 显示当前日期以及下周五对应的日期 1①alter session set nls_date_language='american'; 1select sysdate,next_day(sysdate,'Friday') Friday from dual; 1select sysdate,next_day(sysdate,'Friday') 星期五 from dual; 1②alter session set nls_date_language='simplified chinese'; 1select sysdate,next_day(sysdate,'星期五') 星期五 from dual; 1select sysdate,next_day(sysdate,'星期五') Firday from dual; 5.last_day(d):用于返回特定日期所在月份的最后一天连接查询 包括以下几种连接：不等连接，自连接，外连接 1.使用等值连接1）显示所有雇员的名称，工资以及所在部门名称 1select emp.ename,emp.sal,dept.dname from emp,dept where emp.deptno=dept.deptno; 2）连接查询中使用and指定其他条件显示部门10的部门名，雇员名以及工资 1select dept.dname,emp.ename,emp.sal from emp,dept where emp.deptno=dept.deptno and dept.deptno=10; 在连接查询中使用表别名显示部门30的所有雇员名以及部门位置 1select e.ename,d.loc from emp e,dept d where e.deptno = d.deptno and d.deptno=30; 2.不等连接显示所有雇员的名称，工资以及工资等级 1select e.ename,e.sal,s.grade from emp e,salgrade s where e.sal between s.losal and s.hisal; 3.自连接 自连接是指在同一张表之间的连接查询主要用在自参照表上显示上下级关系或层次关系 如：emp表包含有empno，mgr 1select e.ename || '''SMANAGERIS' || '''MANA' from emp e,emp m where e.mgr = m.empno; 4.外连接 使用（+）操作符完成注：当使用（+）操作符执行外连接时，应该将操作符放在显示较少行（完全满足连接条件行）的那一端 1）显示部门10的部门名，雇员名以及所有其他部门名 1select d.dname,e.ename from dept d,emp e where d.deptno = e.deptno(+) and d.deptno(+)=10; 2）显示部门10的部门名，雇员名以及所有其他雇员名 1select d.dname,e.ename from dept d,emp e where e.deptno=d.deptno(+) and d.deptno(+)=10; 数据分组 数据分组通过函数group by及having共同实现的 1.常用分组函数1）max和min取得雇员的最高工资和最低工资 1select max(sal) 最高工资,min(sal) 最低工资 from emp; 2）avg和sum取得所有雇员的平均工资和工资总和 1select avg(sal) 平均工资,sum(sal) 总计工资 from emp; 3）count取得表emp的雇员总数 1select count(*) 雇员总数 from emp; 2使用group by进行单列分组1）显示每个部门的平均工资 1select deptno,avg(sal) from emp group by deptno; 2)使用group by进行多列分组显示每个部门各种岗位的平均工资和最高工资 1select deptno,job,avg(sal),max(sal) from emp group by deptno,job; 3）使用order by子句改变分组排序结果显示每个部门的部门号以及工资总额，以工资总额进行降序排列 1select deptno,sum(sal) from emp group by deptno order by sum(sal) desc; 3.使用having子句限制分组结果 having子句必须跟在group by子句后面 显示平均工资低于2500的部门号，平均工资以及最高工资 1select deptno,avg(sal),max(sal) from emp group by deptno having avg(sal)&lt;2500; 子查询子查询分为单行子查询，多行子查询和多列子查询1）单行子查询显示SCOTT同部门的所有其他雇员姓名，工资和部门号 1select ename,sal,deptno from emp where deptno=(select deptno from emp where ename='SCOTT') and ename&lt;&gt;'SCOTT'; 2）多行子查询①在多行子查询中使用IN操作符显示匹配于部门10岗位的雇员名，岗位，工资，部门号 1select ename,job,sal,deptno from emp where job in(select distinct job from emp where deptno=10); 2）在多行子查询中使用ALL操作符显示高于部门30所有雇员工资的雇员名，工资和部门号 1select ename,sal,deptno from emp where sal&gt;all(select sal from emp where deptno=30); 3）在多行子查询中使用any显示高于部门30任意雇员工资的雇员名，工资和部门号 1select ename,sal,deptno from emp where sal&gt;any(select sal from emp where deptno=30); 3.多列子查询显示与SMITH部门和岗位完全相同的所有雇员 1select ename,job,sal,deptno from emp where(deptno,job)=(select deptno,job from emp where ename ='SMITH') and ename&lt;&gt;'SMITH';]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[子查询语句]]></title>
    <url>%2F2018%2F03%2F07%2F%E5%AD%90%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[1.查询公司中工资最低的雇员的完整信息 1select * from emp where sal=(select min(sal) from emp); 2.在where子句中使用子查询查询出基本工资比ALLEN低的全部雇员信息 1select * from emp where sal&lt;(select sal from emp where ename='ALLEN'); 3.查询基本工资高于公司平均薪金的全部雇员信息 1select * from emp where sal&gt;(select avg(sal) from emp); 4.查找出与ALLEN从事同一工作，并且基本工资高于雇员编号7521的全部雇员信息 1select * from emp where job=(select job from emp where ename='ALLEN') and sal&gt;(select sal from emp where empno=7521); 5.子查询返回单行多列数据查询与SCOTT从事同一工作且工资相同的雇员信息 1select * from emp where (job,sal)=(select job,sal from emp where ename='SCOTT') and ename&lt;&gt;'SCOTT'; 6.查询出与雇员7566从事同一工作且领导相同的全部雇员信息 1select * from emp where (job,mgr)=(select job,mgr from emp where empno=7566) and empno&lt;&gt;7566; 7.查询与ALLEN从事同一工作且在同一年雇佣的全部雇员信息 1select * from emp where(job,to_char(hiredate,'yyyy'))=(select job,to_char(hiredate,'yyyy') from emp where ename='ALLEN'); 8.子查询返回多行单列数据查询出与每个部门中最低工资相同的全部雇员信息 1select * from emp where sal in(select min(sal) from emp group by deptno); 9.列出每个部门经理的工资 =ANY操作符的效果和IN操作符的效果是一样的 1select * from emp where sal=ANY(select min(sal) from emp where job='MANAGER' group by deptno); &gt;ANY返回的查询结果是比子查询中的最小值还要大的全部数据&lt;ANY返回的查询结果是比子查询中的最大值还要小的全部数据 10. &lt;&gt;ALL：等价于NOT IN但是=ALL并不等价于IN&gt;ALL:比子查询中最大的值还要大，还包含了&gt;=ALL&lt;ALL:比子查询中最小的值还要小，还包含了&lt;=ALL]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分组统计查询]]></title>
    <url>%2F2018%2F03%2F06%2F%E5%88%86%E7%BB%84%E7%BB%9F%E8%AE%A1%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[1.查询出公司每个月支出的月工资的总和 1select sum(sal) from emp; 2.查询出公司的最高工资，最低工资，平均工资 1select max(sal),min(sal),avg(sal),round(avg(sal),2) from emp; 3.统计出公司最早雇佣日期和最晚雇佣日期 1select min(hiredate) 最早雇佣时间,max(hiredate) 最晚雇用时间 from emp; 4.统计出公司的雇员人数 1select count(empno),count(*) from emp; 5.统计出每个部门的人数 1select deptno,count(*) from emp group by deptno; 6.统计出每种职位的最低工资和最高工资 1select job,min(sal),max(sal) from emp group by job; 7.求出每个部门平均工资最高的工资 1select max(avg(sal)) from emp group by deptno; 8.查询每个部门的名称，部门人数，部门平均功能工资，平均服务年限 1select d.dname,count(e.empno),round(avg(e.sal),2) 平均工资,round(avg(months_between(sysdate,hiredate)/12),2) 平均服务年限 from dept d,emp e where e.deptno=d.deptno group by d.dname; 公司明明有4个部门但是只显示3个，是因为有一个部门没有雇员，因此需要使用右外连接 1select d.dname,count(e.empno),round(avg(e.sal),2) 平均工资,round(avg(months_between(sysdate,hiredate)/12),2) 平均服务年限 from dept d,emp e where e.deptno(+)=d.deptno group by d.dname; 9.查询公司各个工资等级雇员的数量，平均工资 1select s.grade,count(e.empno),round(avg(e.sal),2) from emp e,salgrade s where e.sal between s.losal and s.hisal group by s.grade; 10.HAVING子句查询出所有平均工资大于2000元的职位信息，平均工资，雇员人数 1select job,round(avg(sal),2),count(empno) from emp group by job having avg(sal)&gt;2000; 11.列出至少有一个员工的所有部门编号，名称，并统计这些部门的平均工资，最低工资，最高工资 1select d.deptno,d.dname,round(avg(e.sal),2),min(e.sal),max(e.sal) from emp e,dept d where e.deptno=d.deptno group by d.deptno,d.dname,d.loc having count(e.empno)&gt;1; 12.显示非销售人员工作名称以及从事同一工作雇员的月工资的总和，并且要满足从事同一工作的雇员的月工资合计大于5000元，输出结果按月工资的合计升序排列 1select job,sum(sal) sum from emp where job&lt;&gt;'SALESMAN' group by job having sum(sal)&gt;5000 order by sum asc； 总结：在SQL中主要提供了5种分组函数，分别是count,avg,sum,min,max函数使用group by子句可以对数据进行分组操作，而使用having子句可以对分组之后的数据进行再次过滤。]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多表查询]]></title>
    <url>%2F2018%2F03%2F06%2F%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[1.count函数查询emp表中的数据量1select count(*) from emp; 2.查询一个表的结构 desc + 表名称desc dept； 3.将emp，dept表中的笛卡尔积消除掉 注：在多表查询时，由于数据库的检索机制会产生笛卡尔积，笛卡尔积是多张数据表的乘积 1select * from emp,dept where emp.deptno = dept.deptno; 4.多表查询建议在字段查询时采用“表名.字段名”的形式操作查询每个雇员的编号，姓名，职位，基本工资，部门名称，部门位置信息 1select emp.empno,emp.ename,emp.job,emp.sal,dept.dname,dept.loc from emp,dept where emp.deptno=dept.deptno; 5.表中的字段查询时采用“表名.字段名”有时会很长，一般使用“别名.字段名”的形式 1select e.empno,e.ename,e.job,e.sal,d.dname,d.loc from emp e,dept d where e.deptno=d.deptno; 6.查询出每个雇员的编号，姓名，雇佣日期，基本工资，工资等级 1select e.empno,e.ename,e.hiredate,e.sal,s.grade from emp e,salgrade s where e.sal between s.losal and s.hisal; 7.查询每个雇员的姓名，职位，基本工资，部门名称，工资所在公司的工资等级 1select e.ename,e.job,e.sal,d.dname,s.grade from emp e,dept d,salgrade s where e.deptno=d.deptno and e.sal between s.losal and s.hisal; 8.表的自身关联查询每个雇员的编号，姓名及其上级领导的编号，姓名 分析：因为emp表中mgr字段的原因，所以要进行自身连接 1select e.empno,e.ename,m.empno,m.ename from emp e,emp m where e.mgr=m.empno； 运行指令之后发现没有king的信息，是因为king没有上级领导，所以需要使用左外连接，即： 1select e.empno,e.ename,m.empno,m.ename from emp e,emp m where e.mgr=m.empno(+); 注：在oracle中用（+）控制左外连接和右外连接]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单行函数]]></title>
    <url>%2F2018%2F03%2F05%2F%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.字符函数 upper转化为大写lower转化为小写 查询出雇员姓名为SMITH的完整信息，用upper函数将全部内容转化为大写 1select * from emp where ename=upper('smith'); 2.initcap首字母大写查询所有雇员姓名，要求将每个雇员姓名以首字母大写的形式出现 1select ename 原始姓名,initcap(ename) 转化以后的姓名 from emp; 3.replace字符串替换查询所有雇员的姓名，并且将雇员姓名中所有的字母“A”替换为字符“_” 1select ename,replace(ename,'A','_') AS 替换后的姓名 from emp; 4.length字符串长度查询出姓名长度为5的所有雇员信息 1select * from emp where length(ename)=5; 5.substr字符串截取查询姓名前3个字母是JAM的雇员信息 12select * from emp where substr(ename,0,3)='JAM';select * from emp where substr(ename,1,3)='JAM'; 6.查询雇员姓名及雇员姓名的后3个字母 1select ename,substr(ename,-3) AS 截取以后的姓名 from emp; 注：substr函数中可以设置负数截取 oracle中下标从0开始或是从1开始都是一样的 7.数值函数 round数据四舍五入trunc数据截取，不进位 mod取模（取余数） round函数的使用1select round(789.652) 不保留小数,round(789.652,2) 保留两位小数,round(789.652,-1) 处理整数进位 from dual; 不保留小数 保留两位小数 处理整数进位 790 789.65 790 8.验证trunc函数的使用 1select trunc(789.652) 截取小数,trunc(789.652,2) 截取两位小数,trunc(789.652,-2) 取整 from dual; 截取小数 截取两位小数 取整 789 789.65 700 9.验证mod函数的使用 1select mod(10,3) from dual; 10.日期函数取得当前的系统时间sysdate 1select sysdate from dual; 11.查询距离今天为止5天之后以及5天之前的日期 1select sysdate+5 五天之后的日期,sysdate-5 五天之后的日期 from dual; 12.add_months函数：指定的日期上增加若干个月后的日期验证add_months函数 1select sysdate,add_months(sysdate,3) 三个月之后的日期,add_months(sysdate,-3) 三个月之前的日期 from dual; 12col 三个月之后的日期 format A20;col 三个月之前的日期 format A20; 注：sqlplus增加列宽的格式： col 列名 format A×； 13.查询所有雇员在雇佣三个月之后的日期 1select ename,job,hiredate,add_months(hiredate,3) 三个月之后的日期 from emp; 14.last_day函数：日期所在月的最后一天 1select sysdate,last_day(sysdate) 日期所在月的最后一天 from dual; 1col 日期所在月的最后一天 format A30; 15.转换函数to_char函数：将日期数字转化为字符串格式化当前日期 12select sysdate 当前系统时间,to_char(sysdate,'YYYY-MM-DD') 格式化日期 from dual;select sysdate 当前系统时间,to_char(sysdate,'YYYY-MM-DD HH24:MI:SS') 格式化日期 from dual; 注：在oracle中格式化标记不区分大小写，如‘YYYY’可以写成‘yyyy’ 16.查询出所有在每年2月份雇佣的雇员信息 12select * from emp where to_char(hiredate,'MM')='02';select * from emp where to_char(hiredate,'MM')=2; 17.将每个雇员的雇佣日期进行格式化 1select empno,ename,hiredate,to_char(hiredate,'YYYY-mm-dd') 格式化雇用日期 from emp; 18.to_date函数：将日期字符串变为日期型数据 1select TO_DATE('1981-01-31','YYYY-MM-DD') 格式化后的日期 from dual;]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL简单查询]]></title>
    <url>%2F2018%2F03%2F05%2FSQL%E7%AE%80%E5%8D%95%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[1.查询公司中所有雇员的职位信息 1select distinct job from emp; 2.查询公司所有的雇员编号，雇员姓名和年基本工资，日基本工资 123select empno,ename,sal*12,sal/30 from emp;select empno,ename,sal*12 AS 年基本工资,sal/30 AS 日基本工资 from emp;(这里'AS'是设置别名，可有可无) 3.一般在执行语句之前，先会用如下SQL语句查看有多少条数据量 12select count(*) from emp;select count(*) from dept; 4.统计出基本工资高于1500的全部雇员信息 1select * from emp where sal&gt;1500; 5.查询出所有基本工资小于等于2000的全部雇员信息 1select * from emp where sal&lt;=2000; 6.查找SMITH的详细信息 1select * from emp where ename='SMITH'; 7.查询所有业务员（CLERK）的雇员信息 1select * from emp where job='CLERK'; 8.查询所有不是业务员的雇员信息 1select * from emp where job&lt;&gt;'CLERK'; 9.查询出工资范围在1500~3000（包含1500 3000）的全部雇员信息 1select * from emp where sal&gt;=1500 and sal&lt;=3000; 10.查询职位是销售人员，并且基本工资高于1200元的所有雇员信息 1select * from emp where job='SALESMAN' and sal&gt;1200; 11.查询10部门中的经理或者20部门中的业务员的信息 1select * from emp where (deptno=10 and job='MANAGER') or (deptno=20 and job='CLERK'); 12.查询不是业务员且基本工资大于2000的全部雇员信息 1select * from emp where job&lt;&gt;'CLERK' and sal&gt;2000; 13.使用BETWEEN…AND 操作符查询出工资范围在1500~3000的全部雇员信息 1select * from emp where sal between 1500 and 3000; 14.日期的写法： 1981-01-01 ‘01-1月-81’ 或’01-1月-1981’ 1981-12-31 ‘31-12月-81’ 或’31-12月-1981’ 查询出在1981年雇佣的全部雇员信息 1select * from emp where hiredate between '01-1月-81' and '31-12月-81'; 15.空判断（空在数据库中解释为不确定的内容） 使用is null 和is not null（not is null） 查询出所有领取佣金的雇员的完整信息（即佣金不为空的时候） 1select * from emp where comm is not null; 16.查询所有不领佣金的雇员信息的完整情况 1select * from emp where comm is null; 17.列出所有不领取奖金的，同时基本工资大于2000的全部雇员信息 1select * from emp where comm is null and sal&gt;2000; 18.查找出不收取佣金的或收取佣金低于100的员工 1select * from emp where comm is null or comm&lt;100; 19.查找收取佣金的员工的不同工作 1select distinct job from emp where comm is not null; 20.在指定数据范围内查找： in ， not in 查询出雇员编号是7369,7788,7566的雇员信息 1select * from emp where empno in(7369,7788,7566); 注：在使用NOT IN操作符时列表不能有NULL 21.模糊查询：LIKE NOT LIKE 百分号%：匹配0位，1位或多位字符 下划线_：匹配单个任意字符 查询出雇员姓名以S开头的全部雇员信息 1select * from emp where ename like 'S%'; 22.查询出姓名的第2个字母是M的全部雇员信息 1select * from emp where ename like '_M%'; 23.查询姓名中任意位置包含字母F的雇员信息 1select * from emp where ename like '%F%'; 24.查询出基本工资中包含1或者在81年雇佣的全部雇员信息 1select * from emp where sal like'%1%' or hiredate like'%81%'; 25.’%%’ 查询全部直接使用’%%’ 26.查询排序 ORDER BY 排序方式有两种： ASC(默认，不写也是ASC):按照升序的方式排序DESC：按照降序的方式排序 查询雇员的完整信息，并且按照基本工资由高到低进行排序 1select * from emp order by sal desc; 27.查询出所有业务员（CLERK）的详细资料，并且按照基本工资由低到高排序 1select * from emp where job='CLERK' order by sal asc; 28.查询出所有雇员信息，要求按照基本工资由高到低排序，而日期是越早的越小，越近的越大。 1select * from emp order by sal desc,hiredate asc;]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jsp（第一部分）]]></title>
    <url>%2F2018%2F02%2F01%2FJsp%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1 .接收数据操作request.getParameter(String 参数名称)参数名称是表单控件的内容。Demo：input.html 1234&lt;form action="input.jsp" method="post"&gt; 请输入信息：&lt;input type="text" name="msg" id="msg"&gt; &lt;input type="submit" value="发送"&gt;&lt;/form&gt; 接收参数—input.jsp 1234&lt;% String str = request.getParameter("msg");//此时的msg就是表单的name属性 out.println("&lt;h1&gt;" + str + "&lt;/h1&gt;");%&gt; request.getParameter()接收请求参数，返回的类型是String。返回String可以使用正则验证，可以变为任意的数据类型。 2 .Jsp注释显示注释：使用html风格的&lt;!-- 注释 --&gt;。隐式注释：①使用java语言提供的注释，单行注释用//，多行注释用/* ...*/。 ②使用Jsp语言提供的注释，&lt;% -- 注释 --%&gt;。 运行之后只有显示注释的内容会发送到客户端上。 Jsp本身依然还是属于java开发技术，因此依然可以使用java注释。 3 .scriptletjava程序中有Application与Applet（应用小程序）两类程序，而scriptlet就是脚本小程序。只要编写java程序的语句都需要在&lt;% %&gt;之中进行编写，而这样的操作形式就称为scriptlet。根据scriptlet作用不同，可以分为三类：①&lt;% %&gt;在这样的scriptlet中所能够编写的只有局部变量，程序语句。一般而言在一个Jsp的文件里面，使用最多的就是&lt;% %&gt;。②&lt;%! %&gt;这种scriptlet可以定义全局变量，全局常量，方法，类。若定义全局变量，基本上在&lt;%! %&gt;唯一能用到的就是用它定义全局变量。在此类scriptlet里面却可以定义类和方法。③&lt;%= %&gt;out.println()是向页面中进行内容显示输出的，但是在Jsp里面如果要想输出某一个变量或类或常量以及方法的返回值。可以使用表达式输出的scriptlet完整 。&lt;%=变量，变量，方法返回值%&gt;，这种scriptlet可以很好的代替out.println()。out.println()与&lt;%= %&gt;相比最大的好处在于&lt;%= %&gt;代码简化。因此在以后的开发中不使用out.println()输出。 总结：scriptlet定义最多的：局部变量，全局变量，表达式输出内容。 4 .Pagepage主要的功能是定义一个页面中的全部属性，里面包含很多的选项。①解决显示乱码HTML文件乱码可以通过&lt;meta charset=&quot;utf-8&quot;&gt;，浏览器支持的编码可以使用pageEncoding属性，编码依然为utf-8完成。&lt;%@ page pageEncoding=&quot;UTF-8&quot; %&gt;注：编码只能设置一次。②设置MIME属性MIME指的是多路internet媒体访问协议，相当于通过MIME类型定义出当前页面的执行方式，最早的时候除了用pageEncoding解决乱码问题之外，也会利用设置MIME类型的方式来解决乱码。③导入系统开发包在page指令里面几乎所有的指令都能够设置一次，但是只有import指令可以使用多次，表示导入所需要的开发包。&lt;%@ page import=&quot;java.util.*&quot; %&gt;只要可以导包那么就意味着所有的系统类都可以进行调用。因此Jsp页面上就可以进行数据库的操作。 总结：1.解决乱码使用pageEncoding时2.MIME类型一般不需要设置，默认就是“text/html”3.Jsp可以直接使用java中提供的所有类库。 5 .包含指令 第一种：在每一个显示页面里面重复包含有“菜单项”，“头部信息”，“尾部信息”，这三个重复内容。第二种：将“菜单项”，“头部信息”，“尾部信息”分别定义为三个文件，在需要的地方引入。 采用第二种更加适合于代码维护，因此需要使用包含指令。 包含指令有两种提供形式：1）静态包含：&lt;%@ include %&gt;语法：&lt;%@ include file=&quot;包含文件路径&quot;&gt;它可以包含任意的文件内容。如：&lt;%@ include file=”partA.html”&gt;2）动态包含： &lt;jsp:include&gt;静态包含知识将文件的内容简单的包含，如果使用的是动态包含，它可以分为两种处理：①被包含的页面属于静态文件，就像是&lt;%@ include %&gt;一样直接导入进来②被包含的页面属于动态页面，则要分别处理后在进行包含。对于动态包含它所给出的指令形式属于标签指令。所有的标签指令形式有一个特点就是最后必须完结，对于此类语法有两种定义。定义一：包含的时候不传递参数：&lt;jsp:include page=&quot;路径&quot; /&gt;定义二：包含的时候传递参数: 123456&lt;jsp:include page="路径"&gt; &lt;jsp:param name="参数名称" value="参数内容" /&gt; &lt;jsp:param name="参数名称" value="参数内容" /&gt; &lt;jsp:param name="参数名称" value="参数内容" /&gt; ....&lt;/jsp:include&gt; 所有的接收的参数方式使用request.getParameter()完成。在标签指令中如果要使用scriptlet里面定义的变量内容，则必须使用表达式输出的方式&lt;%= %&gt;完成。 总结：两种包含的区别 静态包含： 语法：&lt;%@include file=&quot;路径&quot;%&gt; 处理流程：先包含后处理。 动态包含： 语法：&lt;jsp:include page=&quot;路径&quot;/&gt; 处理流程：如果包含的是静态页面则只是将文件内容导入进来，如果包含的是动态页面，则先分别执行，后将结果包含进来（先处理后包含）。在以后的开发之中，绝对不要使用静态包含，都统一用动态包含。 6 .跳转指令定义一：不向跳转页面传递参数：&lt;jsp:forward page=&quot;路径&quot; /&gt;定义二：向跳转页面传递参数123456&lt;jsp:forward page="路径"&gt; &lt;jsp:param name="参数名称" value="参数内容" /&gt; &lt;jsp:param name="参数名称" value="参数内容" /&gt; &lt;jsp:param name="参数名称" value="参数内容" /&gt; ....&lt;/jsp:forward &gt; 地址栏不改变的跳转是服务端跳转地址栏改变的跳转是客户端跳转 跳转指令与包含指令一样都必须在每次使用后完结。forward跳转之后地址栏不改变，属于服务器端跳转。]]></content>
      <categories>
        <category>Jsp</category>
      </categories>
      <tags>
        <tag>Jsp</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript正则表达式]]></title>
    <url>%2F2018%2F01%2F30%2Fjavascript%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1 .修饰符g：global全文搜索，不添加g，搜索到第一个匹配停止。i：ignore case忽略大小写，默认大小写敏感。He is a boy. Is he? .replace(/\bis\b/g,&#39;0&#39;)He 0 is a boy. Is he? He is a boy. Is he? .replace(/\bis\b/gi,&#39;0&#39;)He 0 is a boy. 0 he?2 .字符类表达式[abc]把字符a或b或c归为一类。&#39;a1b2c3d4&#39;.replace(/[abc]/g,&#39;X&#39;)—-&gt;X1X2X3d4表达式[^abc]表示不是字符a或b或c的内容。&#39;a1b2c3d4&#39;.replace(/[^abc]/g,&#39;X&#39;)—-&gt;aXbXcXXX3 .范围类[a-z]来连接两个字符表示从a到z的任意字符。这是闭区间，包含a到z本身。&#39;a1b2c3x4d9&#39;.replace(/[a-z]/g,&#39;Q&#39;)—&gt;&#39;Q1Q2Q3Q4Q9&#39;[a-zA-Z]&#39;a1b2c3x4d9CDERFV&#39;.replace(/[a-zA-Z]/g,&#39;Q&#39;)—&gt;&#39;Q1Q2Q3Q4Q9QQQQQQ&#39;[0-9]&#39;2015-09-06&#39;.replace(/[0-9]/g,&#39;A&#39;)—&gt;&quot;AAAA-AA-AA&quot;(带横线)&#39;2015-09-06&#39;.replace(/[0-9-]/g,&#39;A&#39;)—&gt;&quot;AAAAAAAAAA&quot;（不带横线）4 .预定义类匹配一个ab+数字+任意字符的字符串—-&gt;ab\d.5 .边界&#39;This is a boy&#39;.replace(/is/g,&#39;0&#39;)—&gt;&quot;Th0 0 a boy&quot;（不带单词边界\b的）&#39;This is a boy&#39;.replace(/\bis\b/g,&#39;0&#39;)—&gt;&quot;This 0 a boy&quot;（带单词边界\b的）&#39;This is a boy&#39;.replace(/\Bis\b/g,&#39;0&#39;)—&gt;&quot;Th0 is a boy&quot;（观察前面无边界后面有边界） &#39;@123@abc@&#39;.replace(/@./g,&#39;Q&#39;)—&gt;&quot;Q23Qbc@&quot;（替换@和任意字符）&#39;@123@abc@&#39;.replace(/^@./g,&#39;Q&#39;)—&gt;&quot;Q23@abc@&quot;（替换以@和任意字符开头的）&#39;@123@abc@&#39;.replace(/.@/g,&#39;Q&#39;)—&gt;&quot;@12QabQ&quot;（替换任意字符和@的）&#39;@123@abc@&#39;.replace(/.@$/g,&#39;Q&#39;)—&gt;&quot;@123@abQ&quot;（替换任意字符和@结束的）6 .量词7 .分组使用（）可以达到分组的效果。&#39;a1b2c3d4&#39;.replace(/[a-z]\d{3}/g,&#39;X&#39;)—&gt;&quot;a1b2c3d4&quot;（不带分组的）&#39;a1b2c3d4&#39;.replace(/([a-z]\d){3}/g,&#39;X&#39;)—&gt;&quot;Xd4&quot;（带分组的）8.反向引用&#39;2015-02-05&#39;.replace(/\d{4}-\d{2}-\d{2}/g,&#39;$1&#39;)—&gt;&quot;$1&quot;&#39;2015-02-05&#39;.replace(/(\d{4})-(\d{2})-(\d{2})/g,&#39;$1&#39;)—&gt;&quot;2015&quot;&#39;2015-02-05&#39;.replace(/(\d{4})-(\d{2})-(\d{2})/g,&#39;$2&#39;)—&gt;&quot;02&quot;&#39;2015-02-05&#39;.replace(/(\d{4})-(\d{2})-(\d{2})/g,&#39;$3&#39;)—&gt;&quot;05&quot;&#39;2015-02-05&#39;.replace(/(\d{4})-(\d{2})-(\d{2})/g,&#39;$2/$3/$1&#39;)—&gt;&quot;02/05/2015&quot;（将年-月-日转换为月/日/年）9 .test方法：用于测试字符串参数中是否存在匹配正则表达式模式的字符串。 推荐网站：https://regexper.com]]></content>
      <categories>
        <category>JavaScript</category>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>javascript</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript复习]]></title>
    <url>%2F2018%2F01%2F30%2Fjavascript%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[HTML DOM 树1 .节点及其类型1）元素节点：html各个标签就是元素节点。2）属性节点：标签中元素的属性，如：href class ……3）文本节点：是元素节点的子节点，其内容为文本。 2 .如何获取元素节点：①document.getElementById：根据id属性获取对应的单个节点。用法：var element = document.getElementById(ID);demo： 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;javascript&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;script type="text/javascript"&gt; window.onload = function() &#123; //获取 id 为 bj 的那个节点. //在编写 HTML 文档时, 需确保 id 属性值是唯一的. //该方法为 document 对象的方法 var bjNode = document.getElementById("bj"); alert(bjNode); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;你喜欢哪个城市？&lt;/p&gt; &lt;ul&gt; &lt;li id="bj"&gt;北京&lt;/li&gt; &lt;li&gt;上海&lt;/li&gt; &lt;li&gt;东京&lt;/li&gt; &lt;li&gt;首尔&lt;/li&gt; &lt;/ul&gt; &lt;br&gt;&lt;br&gt; &lt;p&gt;你喜欢哪款单机游戏？&lt;/p&gt; &lt;ul&gt; &lt;li&gt;红警&lt;/li&gt; &lt;li&gt;实况&lt;/li&gt; &lt;li&gt;极品飞车&lt;/li&gt; &lt;li&gt;魔兽&lt;/li&gt; &lt;/ul&gt; &lt;br&gt;&lt;br&gt; gender:&lt;input type="radio" name="gender" value="male"&gt;Male &lt;input type="radio" name="gender" value="female"&gt;female&lt;/body&gt;&lt;/html&gt; 运行结果：注：后面的demo没有特别说明都会采用body中的实例。 ②document.getElementsByTagName：根据标签名获取指定节点名字的数组，数组对象length属性可以获取数组长度。用法1：var elements = element.getElementsByTagName(tagName)demo: 12345678910111213141516171819&lt;html&gt;&lt;head&gt; &lt;title&gt;javascript&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;script type="text/javascript"&gt; window.onload = function() &#123; // 获取所有的 button 节点. 并取得第一个元素 var btn = document.getElementsByTagName("button")[0]; //为 button 的 onclick 事件赋值: 当点击 button 时, 执行函数体 btn.onclick = function() &#123; alert("Hello World"); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;Click On&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 123456789&lt;script type="text/javascript"&gt; window.onload = function() &#123; // 获取所有的 li 节点. //使用标签名获取指定节点的集合. //该方法为 Node 接口的方法, 即任何一个节点都有这个方法. var liNode = document.getElementsByTagName("li"); alert(liNode.length); &#125;&lt;/script&gt; 运行后的结果： 用法2demo： 1234567&lt;script type="text/javascript"&gt; window.onload = function() &#123; var cityNode = document.getElementById("city"); var cityLiNode = cityNode.getElementsByTagName("li"); alert(cityLiNode.length); &#125;&lt;/script&gt; 运行后的结果： ③document.getElementsByName：根据节点的name属性获取符合条件的节点数组。Demo： 1234567&lt;script type="text/javascript"&gt; window.onload = function() &#123; //根据 HTML 文档元素的 name 属性名来获取指定的节点的集合. var genderNode = document.getElementsByName("gender"); alert(genderNode.length); &#125;&lt;/script&gt; 运行后的结果： 3 .如何获取属性节点1）直接通过cityNode.id这样的方式来获取和设置属性节点。 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;javascript&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;script type="text/javascript"&gt; //读写属性节点: 通过元素节点 . 的方式来获取属性值和设置属性值. window.onload = function() &#123; //属性节点即为某一指定的元素节点的属性. //1. 先获取指定的那个元素节点 var nameNode = document.getElementById("name"); //2. 再读取指定属性的值 alert(nameNode.value); //3. 设置指定的属性的值. nameNode.value = "菲菲"; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;你喜欢哪个城市?&lt;/p&gt; &lt;ul id="city"&gt; &lt;li id="bj" name="BeiJing"&gt;北京&lt;/li&gt; &lt;li&gt;上海&lt;/li&gt; &lt;li&gt;东京&lt;/li&gt; &lt;li&gt;首尔&lt;/li&gt; &lt;/ul&gt; &lt;br&gt;&lt;br&gt; &lt;p&gt;你喜欢哪款单机游戏?&lt;/p&gt; &lt;ul id="game"&gt; &lt;li id="rl"&gt;红警&lt;/li&gt; &lt;li&gt;实况&lt;/li&gt; &lt;li&gt;极品飞车&lt;/li&gt; &lt;li&gt;魔兽&lt;/li&gt; &lt;/ul&gt; &lt;br&gt;&lt;br&gt; name: &lt;input type="text" name="username" id="name" value="feifei"/&gt;&lt;/body&gt;&lt;/html&gt; 2）通过元素节点的getAttributeNode方法来获取属性节点，然后再通过nodeValue 来读写属性值。 12345678910&lt;script type="text/javascript"&gt; window.onload = function() &#123; var nameNode = document.getElementById("name"); var nameAttr = nameNode.getAttributeNode("value"); alert(nameNode); alert(nameAttr); alert(nameAttr.nodeValue); nameAttr.nodeValue = "菲菲" ; &#125;&lt;/script&gt; 注：1）2）的boy部分一样。 4 .获取元素节点的子节点（只有元素节点才有子节点）①firstChild属性获取第一个子节点。②lastChild属性获取最后一个子节点。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;Untitled Document&lt;/title&gt; &lt;script type="text/javascript"&gt; //获取元素节点的子节点 window.onload = function()&#123; //1. 获取 #city 节点的所有子节点. var cityNode = document.getElementById("city"); //2. 利用元素节点的 childNodes 方法可以获取指定元素节点的所有子节点. //但该方法不实用. alert(cityNode.childNodes.length); //3. 获取 #city 节点的所有 li 子节点. var cityLiNodes = cityNode.getElementsByTagName("li"); alert(cityLiNodes.length); //4. 获取指定节点的第一个子节点和最后一个子节点. alert(cityNode.firstChild); alert(cityNode.lastChild); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;你喜欢哪个城市?&lt;/p&gt;&lt;!--注意下面ul和li标签有无空格。--&gt; &lt;ul id="city"&gt;&lt;li id="bj" name="BeiJing"&gt;北京&lt;/li&gt; &lt;li&gt;上海&lt;/li&gt; &lt;li&gt;东京&lt;/li&gt; &lt;li&gt;首尔&lt;/li&gt; &lt;/ul&gt; &lt;br&gt;&lt;br&gt; &lt;p&gt;你喜欢哪款单机游戏?&lt;/p&gt; &lt;ul id="game"&gt; &lt;li id="rl"&gt;红警&lt;/li&gt; &lt;li&gt;实况&lt;/li&gt; &lt;li&gt;极品飞车&lt;/li&gt; &lt;li&gt;魔兽&lt;/li&gt; &lt;/ul&gt; &lt;br&gt;&lt;br&gt; name: &lt;input type="text" name="username" id="name" value="feifei"/&gt; &lt;/body&gt;&lt;/html&gt; 5 .节点的属性：1）nodeName ：代表当前节点的名字，只读属性。如果给定节点是一个文本节点，nodeName属性将返回内容为#text的字符串。2）nodeType：返回一个整数，这个数值代表给定节点的类型，只读属性。1——代表元素节点，2——代表属性节点，3——代表文本节点。3）` nodeValue ：返回给定节点的当前值（字符串）。可读写的属性。①元素节点：返回值是null、②属性节点：返回值是这个属性的值、③文本节点：返回值是这个文本节点的内容。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;Untitled Document&lt;/title&gt; &lt;script type="text/javascript"&gt; //关于节点的属性: nodeType, nodeName, nodeValue //在文档中, 任何一个节点都有这 3 个属性 //而 id, name, value 是具体节点的属性. window.onload = function()&#123; //1. 元素节点的这 3 个属性 var bjNode = document.getElementById("bj"); alert(bjNode.nodeType); //元素节点: 1 alert(bjNode.nodeName); //节点名: li alert(bjNode.nodeValue); //元素节点没有 nodeValue 属性值: null //2. 属性节点 var nameAttr = document.getElementById("name") .getAttributeNode("name"); alert(nameAttr.nodeType); //属性节点: 2 alert(nameAttr.nodeName); //属性节点的节点名: 属性名 alert(nameAttr.nodeValue); //属性节点的 nodeValue 属性值: 属性值 //3. 文本节点: var textNode = bjNode.firstChild; alert(textNode.nodeType); //文本节点: 0 alert(textNode.nodeName); //节点名: #text alert(textNode.nodeValue); //文本节点的 nodeValue 属性值: 文本值本身. //nodeType、nodeName 是只读的. //而 nodeValue 是可以被改变的。 //以上三个属性, 只有在文本节点中使用 nodeValue 读写文本值时使用最多. &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;你喜欢哪个城市?&lt;/p&gt; &lt;ul id="city"&gt;ccc &lt;li id="bj" name="BeiJing"&gt;北京&lt;/li&gt; &lt;li&gt;上海&lt;/li&gt; &lt;li&gt;东京&lt;/li&gt; &lt;li&gt;首尔&lt;/li&gt; &lt;/ul&gt; &lt;br&gt;&lt;br&gt; &lt;p&gt;你喜欢哪款单机游戏?&lt;/p&gt; &lt;ul id="game"&gt; &lt;li id="rl"&gt;红警&lt;/li&gt; &lt;li&gt;实况&lt;/li&gt; &lt;li&gt;极品飞车&lt;/li&gt; &lt;li&gt;魔兽&lt;/li&gt; &lt;/ul&gt; &lt;br&gt;&lt;br&gt; name: &lt;input type="text" name="username" id="name" value="feifei"/&gt; &lt;/body&gt;&lt;/html&gt; 6 .创建一个元素节点：1）createElement()：按照给定的标签名创建一个新的元素节点。方法只有一个参数：被创建的元素节点的名字，是一个字符串。var reference = document.createElement(element);方法的返回值：是一个指向新建节点的引用指针，返回值是一个元素节点，所以它的nodeType属性值等于1.新元素节点不会自动添到文档里，它只是一个存在于javascript上下文的对象。var oP = document.createElement(&quot;p&quot;); 7 .创建一个文本节点：createTextNode()：创建一个包含给定文本的新文本节点。方法只有一个参数：新建文本节点所包含的文本字符串。var reference = document.createTextNode(text);方法返回值：是一个指向新建节点的引用指针,返回值是一个元素节点，所以它的nodeType属性值等于3.var oText = document.createTextNode(&quot;Hello World&quot;); 8 .为元素节点添加子节点：appendChild()：var reference = element.appenChild(newChild)：给定子节点newChild将成为给定元素节点element的最后一个子节点。方法返回值是一个指向新增子节点的引用指针。 6.7.8联合的demo 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;javascript&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;script type="text/javascript"&gt; window.onload = function() &#123; alert("添加"); //1. document.createElement(elementTagName) //新创建一个元素节点, 返回值为指向元素节点的引用 //&lt;li&gt;&lt;/li&gt; var liNode = document.createElement("li"); //2. 创建 "广州" 的文本节点 //document.createTextNode(string) 创建一个文本节点 //参数为文本值, 返回该文本节点的引用. var textNode = document.createTextNode("广州"); //&lt;li&gt;厦门&lt;/li&gt; liNode.appendChild(textNode); var cityNode = document.getElementById("city"); //2. elementNode.appendChild(newChild): 为 elementNode //新添加 newChild 子节点, 该子节点将作为 elementNode 的最后 //一个子节点. cityNode.appendChild(liNode); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;你喜欢哪个城市?&lt;/p&gt; &lt;ul id="city"&gt; &lt;li id="bj" name="BeiJing"&gt;北京&lt;/li&gt; &lt;li&gt;上海&lt;/li&gt; &lt;li&gt;东京&lt;/li&gt; &lt;li&gt;首尔&lt;/li&gt; &lt;/ul&gt; &lt;br&gt;&lt;br&gt; &lt;p&gt;你喜欢哪款单机游戏?&lt;/p&gt; &lt;ul id="game"&gt; &lt;li id="rl"&gt;红警&lt;/li&gt; &lt;li&gt;实况&lt;/li&gt; &lt;li&gt;极品飞车&lt;/li&gt; &lt;li&gt;魔兽&lt;/li&gt; &lt;/ul&gt; &lt;br&gt;&lt;br&gt; name: &lt;input type="text" name="username" id="name" value="feifei"/&gt;&lt;/body&gt;&lt;/html&gt; 9 .插入节点1）insertBefore():把一个给定节点插入到一个给定元素节点的给定子节点的前面var reference = element.insertBefore(newNode,targetNode);节点newNode将被插入到元素节点element中并出现在节点targetNode的前面。节点targetNode必须是element元素的一个子节点。 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;javascript&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;script type="text/javascript"&gt; window.onload = function() &#123; alert("添加"); var cityNode = document.getElementById("city"); var djNode = document.getElementById("dj"); var rlNode = document.getElementById("rl"); cityNode.insertBefore(rlNode,djNode); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;你喜欢哪个城市?&lt;/p&gt; &lt;ul id="city"&gt;&lt;li id="bj" name="BeiJing"&gt;北京&lt;/li&gt; &lt;li&gt;上海&lt;/li&gt; &lt;li id="dj"&gt;东京&lt;/li&gt; &lt;li id="se"&gt;首尔&lt;/li&gt; &lt;/ul&gt; &lt;br&gt;&lt;br&gt; &lt;p&gt;你喜欢哪款单机游戏?&lt;/p&gt; &lt;ul id="game"&gt; &lt;li id="rl"&gt;红警&lt;/li&gt; &lt;li&gt;实况&lt;/li&gt; &lt;li&gt;极品飞车&lt;/li&gt; &lt;li&gt;魔兽&lt;/li&gt; &lt;/ul&gt; &lt;br&gt;&lt;br&gt; gender: &lt;input type="radio" name="gender" value="male"/&gt;Male &lt;input type="radio" name="gender" value="female"/&gt;Female &lt;br&gt;&lt;br&gt; name: &lt;input type="text" name="username" value="feifei"/&gt;&lt;/body&gt;&lt;/html&gt; 10 .删除节点1）removeChild()：从一个给定元素里删除一个子节点。var reference = element.removeChild(node);返回值是一个指向已被删除的子节点的引用指针。某个节点被removeChild()方法删除时，这个节点所包含的所有子节点将同时被删除。如果想删除某个节点，但不知道它的父节点是哪一个，parentNode属性可以帮忙。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;javascript&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;script type="text/javascript"&gt; window.onload = function() &#123; var liNode = document.getElementsByTagName("li"); for (var i=0;i&lt;liNode.length;i++) &#123; liNode[i].onclick = function() &#123; var flg = confirm("确定要删除" +this.firstChild.nodeValue+ "的信息吗？"); if(flg) &#123; this.parentNode.removeChild(this); &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;你喜欢哪个城市?&lt;/p&gt; &lt;ul id="city"&gt;&lt;li id="bj" name="BeiJing"&gt;北京&lt;/li&gt; &lt;li&gt;上海&lt;/li&gt; &lt;li id="dj"&gt;东京&lt;/li&gt; &lt;li id="se"&gt;首尔&lt;/li&gt; &lt;/ul&gt; &lt;br&gt;&lt;br&gt; &lt;p&gt;你喜欢哪款单机游戏?&lt;/p&gt; &lt;ul id="game"&gt; &lt;li id="rl"&gt;红警&lt;/li&gt; &lt;li&gt;实况&lt;/li&gt; &lt;li&gt;极品飞车&lt;/li&gt; &lt;li&gt;魔兽&lt;/li&gt; &lt;/ul&gt; &lt;br&gt;&lt;br&gt; gender: &lt;input type="radio" name="gender" value="male"/&gt;Male &lt;input type="radio" name="gender" value="female"/&gt;Female &lt;br&gt;&lt;br&gt; name: &lt;input type="text" name="username" value="feifei"/&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript（九）windows对象]]></title>
    <url>%2F2018%2F01%2F21%2Fjavascript%EF%BC%88%E4%B9%9D%EF%BC%89windows%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[1 .在windows对象里面有一个confirm（）函数，这个函数的主要功能是提供一个确认框。 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;实验课&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;script type="text/javascript"&gt; function deleteConfirm() &#123; return window.confirm("确定要删除吗？"); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;a href="Xxx" onclick="return deleteConfirm()"&gt;删除邮件&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 2 .还有一个prompt（）函数，此函数可以由用户输入数据。 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;实验课&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;script type="text/javascript"&gt; var str = window.prompt("请输入你的姓名","姓名是？"); document.write(str); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 3 .还可以在一个页面里面打开另外一个页面。使用window.open（）函数 123&lt;script type="text/javascript"&gt; window.open('show.html');&lt;/script&gt; 在弹框的时候也可以设置一些显示属性 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;实验课&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="CSS/feifei.css"&gt; &lt;meta charset="utf-8"&gt; &lt;script type="text/javascript"&gt; window.open('show.html',"AD页","width=500;height=30;scollbars=yes;resizeable=no"); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 4 .使用window.close（）关闭窗口 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;实验课&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="CSS/feifei.css"&gt; &lt;meta charset="utf-8"&gt; &lt;script type="text/javascript"&gt; function fun() &#123; window.close(); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button onclick="fun()"&gt;关闭&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 5 .还有一个重要的操作：重定向：window.location（） 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;实验课&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="CSS/feifei.css"&gt; &lt;meta charset="utf-8"&gt; &lt;script type="text/javascript"&gt; function go(url) &#123; window.location = url ; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;select id="url" name="url" onchange="go(this.value)"&gt; &lt;option&gt;== 请选择要显示的页面 ===&lt;/option&gt; &lt;option value="show.html"&gt;SHOW&lt;/option&gt; &lt;option value="www.lfeifei.com"&gt;feifei&lt;/option&gt; &lt;/select&gt;&lt;/body&gt;&lt;/html&gt; window对象表示的是窗口的操作：重要的是location，open，close。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript（八）表单处理事件]]></title>
    <url>%2F2018%2F01%2F20%2Fjavascript%EF%BC%88%E5%85%AB%EF%BC%89%E8%A1%A8%E5%8D%95%E5%A4%84%E7%90%86%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[javascript表单单选框 1 .javascript表单单选框 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;javascript&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;link rel="stylesheet" type="text/css" href="CSS/feifei.css"&gt; &lt;script type="text/javascript"&gt; function showSex() &#123; var sex = document.all("sex"); if(sex[0].checked) &#123; alert("性别是：" +sex[0].value); &#125; if(sex[1].checked) &#123; alert("性别是:" + sex[1].value); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; 请选择性别：&lt;input type="radio" name="sex" id="sex" value="男" checked&gt; 男&amp;nbsp; &lt;input type="radio" name="sex" id="sex" value="女"&gt;女&lt;br&gt; &lt;button onclick="showSex()"&gt;显示性别&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 2 .javascript表单复选框 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;实验课&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;script type="text/javascript"&gt; function showInst() &#123; var inst = document.all("inst"); var str = "小狗的兴趣：" ; for(var x=0;x&lt;inst.length;x++) &#123; if(inst[x].checked) &#123; str += inst[x].value + "、" ; &#125; &#125; alert(str); &#125; function selectAll() &#123; var inst = document.all("inst"); for(var x=0; x&lt;inst.length; x++) &#123; inst[x].checked = document.getElementById("sela").checked; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; 你的兴趣爱好：&lt;br&gt; &lt;input type="checkbox" name="inst" id="inst" value="上网"&gt;上网&lt;br&gt; &lt;input type="checkbox" name="inst" id="inst" value="打游戏"&gt;打游戏&lt;br&gt; &lt;input type="checkbox" name="inst" id="inst" value="唱歌"&gt;唱歌&lt;br&gt; &lt;input type="checkbox" name="inst" id="inst" value="画画"&gt;画画&lt;br&gt; &lt;input type="checkbox" name="inst" id="inst" value="打篮球"&gt;打篮球&lt;br&gt; &lt;input type="checkbox" name="inst" id="inst" value="打排球"&gt;打排球&lt;br&gt; &lt;input type="checkbox" name="inst" id="inst" value="旅行"&gt;旅行&lt;br&gt; &lt;input type="checkbox" name="inst" id="inst" value="吃吃吃"&gt;吃吃吃&lt;br&gt;&lt;br&gt; &lt;input type="checkbox" id="sela" name="sela" onclick="selectAll()"&gt;全选 &lt;button onclick="showInst()"&gt;显示&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 3 .javascript表单下拉列表框下拉列表框如果要进行表单交互使用的事件是onchange事件。表示下拉内容发生改变。 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;实验课&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;script type="text/javascript"&gt; function showCity(city) &#123; alert("家乡是：" + city); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; 你的家乡：&lt;select name="city" id="city" onchange="showCity(this.value)"&gt; &lt;option value="北京-BJ"&gt;北京&lt;/option&gt; &lt;option value="上海-SH"&gt;上海&lt;/option&gt; &lt;option value="沈阳-SY"&gt;沈阳&lt;/option&gt; &lt;/select&gt; &lt;/body&gt;&lt;/html&gt; 4 .javascript文本域： 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;实验课&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;script type="text/javascript"&gt; function validateNote() &#123; var note = document.getElementById("note"); var msg = document.getElementById("noteMsg"); var len = note.value.length; if(len &lt;= 10) &#123; msg.innerHTML = "还可以输入" +(10 - len) + "个长度的数据"; document.getElementById("sub").disabled = "" ; &#125; else &#123; msg.innerHTML = "&lt;font color='red'&gt;输入的数据内容过大，不符合&lt;/font&gt;"; document.getElementById("sub").disabled = "disabled" ; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="show.html" method="post"&gt; 描述：&lt;textarea id="note" name="note" cols="50" rows="10" onkeypress="validateNote()" onkeydown="validateNote()"&gt;hello&lt;/textarea&gt;&lt;br&gt; &lt;span id="noteMsg"&gt;&lt;/span&gt;&lt;br&gt; &lt;button type="submit" name="sub" id="sub"&gt;保存&lt;/button&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript（七）表单密码验证]]></title>
    <url>%2F2018%2F01%2F20%2Fjavascript%EF%BC%88%E4%B8%83%EF%BC%89%E8%A1%A8%E5%8D%95%E5%AF%86%E7%A0%81%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[javascript表单密码验证 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;javascript&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;link rel="stylesheet" type="text/css" href="CSS/feifei.css"&gt; &lt;script type="text/javascript" src="js/demo.js"&gt; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; 输入密码： &lt;input type="password" name="pwd" id="pwd" class="init"&gt;&lt;span id="pwdMsg"&gt;&lt;/span&gt;&lt;br&gt; 确认密码： &lt;input type="password" name="conf" id="conf" class="init"&gt;&lt;span id="confMsg"&gt;&lt;/span&gt;&lt;br&gt;&lt;/body&gt;&lt;/html&gt; js/demo.js：12345678910111213141516171819202122232425262728293031323334353637383940function validateEmpty(elementName) &#123; var objElement = document.getElementById(elementName); var msgElement = document.getElementById(elementName + "Msg"); if(objElement.value != "") &#123; objElement.className = "right" ; msgElement.innerHTML = "&lt;font color='green'&gt;输入的内容正确&lt;/font&gt;" ; return true; &#125; else &#123; objElement.className = "wrong" ; msgElement.innerHTML = "&lt;font color='red'&gt;输入的内容错误&lt;/font&gt;" ; return false; &#125;&#125;function validateRepeat(srcName,desName) &#123; var srcElement = document.getElementById(srcName); var desElement = document.getElementById(desName); var msgElement = document.getElementById(desName + "Msg"); if(srcElement.value == desElement.value) &#123; desElement.className = "right" ; msgElement.innerHTML = "&lt;font color='green'&gt;输入的内容正确&lt;/font&gt;" ; return true; &#125; else &#123; desElement.className = "wrong" ; msgElement.innerHTML = "&lt;font color='red'&gt;输入的内容错误&lt;/font&gt;" ; return false; &#125;&#125;function validatePwd() &#123; return validateEmpty("pwd");&#125;function validateConf() &#123; if(validateEmpty("conf")) &#123; return validateRepeat("pwd","conf"); &#125; return false;&#125;window.onload = function() &#123; document.getElementById("pwd").addEventListener("blur",validatePwd,false); document.getElementById("conf").addEventListener("blur",validateConf,false);&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript（六）表单验证]]></title>
    <url>%2F2018%2F01%2F19%2Fjavascript%EF%BC%88%E5%85%AD%EF%BC%89%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[前言:表单数据的取得以及验证是在整个javascript里面使用最重要的一个场景 1 . 所有的javascript中事件一定要与函数捆绑在一起使用，因此就利用这些事件来进行表单元素的操作。Demo：取得输入的文本信息注：在表单控件里面name和id的内容一定要保持一致。 12345678910111213141516&lt;html&gt;&lt;head&gt; &lt;title&gt;javascript&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;script type="text/javascript"&gt; function showEmail() &#123; //定义事件的处理函数 var emailElement = document.getElementById("email"); alert("EMAIL = " + emailElement.value); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form&gt;请输入email地址：&lt;input type="text" name="email" id="email" value=""&gt;&lt;/form&gt; &lt;button onclick="showEmail()"&gt;显示内容&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 2 . 在取得了输入的内容之后，更多的是希望进行数据的验证，因为只有合法的email才应该进行正常的显示。要想使用数据验证，正则表达式是最方便的，而javascript也支持。一定要定义正则的开始与结束标记，而且所有的正则符号不在需要转义。语法： “/^正则$/.test（要检测的数据）”Demo1:1234567891011121314151617181920212223&lt;html&gt;&lt;head&gt; &lt;title&gt;javascript&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;script type="text/javascript"&gt; function showEmail() &#123; //定义事件处理函数 var emailElement = document.getElementById("email"); if(/^\w+@\w+\.\w+$/.test(emailElement.value)) &#123; alert("输入的数据合法"); &#125; else &#123; alert("输入的数据不合法"); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form&gt; 请输入email地址：&lt;input type="text" name="email" id="email" value=""&gt; &lt;button onclick="showEmail()"&gt;显示内容&lt;/button&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; Demo2: 1234567891011121314151617181920212223&lt;html&gt;&lt;head&gt; &lt;title&gt;javascript&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;script type="text/javascript"&gt; function showEmail() &#123; //定义事件处理函数 var emailElement = document.getElementById("email"); if(/^\w+@\w+\.\w+$/.test(emailElement.value)) &#123; alert("输入的数据合法"); &#125; else &#123; alert("输入的数据不合法"); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form id="myform" action="show.html" method="post"&gt; 请输入email地址：&lt;input type="text" name="email" id="email" value=""&gt; &lt;button type="submit" onclick="showEmail()"&gt;显示内容&lt;/button&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; show.html:&lt;h1&gt;数据验证成功，表单正常提交&lt;/h1&gt; 运行后的结果是：输入的数据合法或不合法 都可以提交表单。3 .一个正常的表单验证操作过程之中，其基本流程： 由用户输入表单内容，如果输入的数据合法，则允许提交；如果不合法则不允许提交。 针对表单验证进行拦截，必须使用onsubmit事件。这个事件是在&lt;form&gt;元素上定义的，表示进行表单提交时触发。 如果需要对表单进行拦截，那么就在onsubmit处理函数上返回false，如果正常执行返回true 。 Demo1:1234567891011121314151617181920212223242526&lt;head&gt; &lt;title&gt;javascript&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;script type="text/javascript"&gt; function validateEmail() &#123; //定义事件处理函数 var emailElement = document.getElementById("email"); if(/^\w+@\w+\.\w+$/.test(emailElement.value)) &#123; alert("输入的数据合法"); return true; &#125; else &#123; alert("输入的数据不合法"); return false; &#125; &#125; function validate() &#123; return validateEmail(); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form id="myform" action="show.html" method="post" onsubmit="return validate()"&gt; 请输入email地址：&lt;input type="text" name="email" id="email" value=""&gt; &lt;button type="submit" onclick="showEmail()"&gt;显示内容&lt;/button&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 运行结果正常，表单正常提交。但是总有万恶的弹框，接下来，改进Demo，在每一个表单初始状态时使用 &quot;.init&quot;样式完成，而如果验证失败使用&quot;.wrong&quot;样式完成，反之使用&quot;.right&quot;样式完成。Demo2: 12345678910111213141516171819202122232425262728&lt;html&gt;&lt;head&gt; &lt;title&gt;javascript&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;link rel="stylesheet" type="text/css" href="CSS/feifei.css"&gt; &lt;script type="text/javascript"&gt; function validateEmail() &#123; //定义事件处理函数 var emailElement = document.getElementById("email"); if(/^\w+@\w+\.\w+$/.test(emailElement.value)) &#123; emailElement.className = "right"; return true; &#125; else &#123; emailElement.className = "wrong"; return false; &#125; &#125; function validate() &#123; return validateEmail(); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form id="myform" action="show.html" method="post" onsubmit="return validate()"&gt; 请输入email地址：&lt;input type="text" name="email" id="email" value="" class="init"&gt;&lt;br&gt; &lt;button type="submit"&gt;显示内容&lt;/button&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617.init &#123; background: #F5F5F5; font-weight: bold; color: #000000;&#125;.wrong &#123; background: #F5F5F5; font-weight: bold; border: 1px #FF0000 solid; color: #000000;&#125;.right &#123; background: #F5F5F5; font-weight: bold; border: 1px #00FF00 solid; color: #000000;&#125; 最好的验证方式是在文本框失去焦点之后进行验证。获得焦点的事件是：onfocus失去焦点的事件是：onblurDemo3： 12345678910111213141516171819202122232425262728293031&lt;html&gt;&lt;head&gt; &lt;title&gt;javascript&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;link rel="stylesheet" type="text/css" href="CSS/feifei.css"&gt; &lt;script type="text/javascript"&gt; function validateEmail() &#123; //定义事件处理函数 var emailElement = document.getElementById("email"); var msgElement = document.getElementById("emailMsg"); if(/^\w+@\w+\.\w+$/.test(emailElement.value)) &#123; emailElement.className = "right"; msgElement.innerHTML = "email输入正确"; return true; &#125; else &#123; emailElement.className = "wrong"; msgElement.innerHTML = "email输入错误"; return false; &#125; &#125; function validate() &#123; return validateEmail(); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form id="myform" action="show.html" method="post" onsubmit="return validate()"&gt; 请输入email地址：&lt;input type="text" name="email" id="email" value="" class="init" onblur="validateEmail()"&gt;&lt;span id="emailMsg"&gt;&lt;/span&gt;&lt;br&gt; &lt;button type="submit"&gt;显示内容&lt;/button&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 另外改进：Demo4：提示的字体颜色msgElement.innerHTML = &quot;&lt;font color=&#39;green&#39;&gt; email输入正确 &lt;/font&gt;&quot;;msgElement.innerHTML = &quot;&lt;font color=&#39;red&#39;&gt; email输入错误 &lt;/font&gt;&quot;;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript（五）动态绑定事件]]></title>
    <url>%2F2018%2F01%2F19%2Fjavascript%EF%BC%88%E4%BA%94%EF%BC%89%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[javascript动态绑定事件1 . 首先看如下Demo： 123456789&lt;script type="text/javascript"&gt; function handle() &#123; //修改当前行元素 alert("事件绑定！"); &#125; //表示是在页面加载的时候进行加载事件的处理 window.onload = function() &#123; //匿名函数 handle(); &#125;&lt;/script&gt; 2 . 使用addEventListener（事件类型，处理函数名称，触发时机）进行动态设置。 注：对于整个javascript事件的处理分为两个部分： 1）事件的冒泡过程 2）事件的触发过程 触发时机都为false，表示在事件的触发过程进行处理，阻止事件的冒泡。 所有的动态设置的事件都可以在onload里面进行动态的配置，但是如果配置必须能够取得一个明确的元素对象可以使用“document.getElementById（元素ID）”的操作方式取得元素对象。Demo1：123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;javascript&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;script type="text/javascript"&gt; function handle() &#123; //修改当前行元素 alert("事件绑定！"); &#125; //表示是在页面加载的时候进行加载事件的处理 window.onload = function() &#123; //匿名函数 var imgElement = document.getElementById("myimg"); imgElement.addEventListener("click",handle,false); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- id是整个javascript的操作核心所在，必须存在 --&gt; &lt;img id="myimg" src="52.jpeg" height="20%" width="20%"&gt;&lt;/body&gt;&lt;/html&gt; 注：以后会通常使用这种代码，这种代码格式的好处：HTML和Javascript不会混合。Demo2： 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;javascript&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;script type="text/javascript"&gt; window.onload = function() &#123; var butElement = document.getElementById("setBut"); //取得了setBut元素的对象 butElement.addEventListener("click",function() &#123; //在此元素内容增加指定的内容，而且内容可以是HTML代码 document.getElementById("info").innerHTML = "&lt;img src= '52.jpeg' height='40%' width='20%'&gt;"; &#125;,false); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;span id="info"&gt;&lt;/span&gt; &lt;button id="setBut"&gt;设置显示图片&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 3 .下面为一个小功能的扩充，实现一个图片浏览器。 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;javascript&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;script type="text/javascript"&gt; var imgName = new Array("pica.jpg","picb.jpg","picc.jpg","picd.jpg","pice.jpg","picf.jpg"); var foot = 1; window.onload = function() &#123; var pbut = document.getElementById("previousButton"); var nbut = document.getElementById("nextButton"); var img = document.getElementById("img"); nbut.addEventListener("click",function() &#123; if(foot &gt;= imgName.length) &#123; foot = 0; &#125; img.src = "images/" + imgName[foot++]; &#125;,false); pbut.addEventListener("click",function() &#123; if(foot &lt;= imgName.length) &#123; foot = imgName.length-1; &#125; img.src = "images/" + imgName[foot--]; &#125;,false); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;span id="info"&gt; &lt;img id="img" src="images/pica.jpg" height="50%"&gt; &lt;/span&gt; &lt;div id="controlDiv"&gt; &lt;button id="previousButton"&gt;上一张&lt;/button&gt; &lt;button id="nextButton"&gt;下一张&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 4 . 在javascript中提供一个setTimout（函数，时间-毫秒）利用此函数可以实现定期的操作调用。如下Demo1： 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;javascript&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;/head&gt;&lt;body&gt; &lt;span id="info"&gt;hello&lt;/span&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; function setClick() &#123; var date = new Date(); //取当前时间 var info = document.getElementById("info"); info.innerHTML = "当前时间" + date ; setTimeout(setClick,1000); //每秒更新一次 &#125; setClick();&lt;/script&gt;&lt;/html&gt; Demo2：图片定时浏览 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;javascript&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;/head&gt;&lt;body&gt; &lt;span id="info"&gt; &lt;img id="img" src="images/pica.jpg" height="40%"&gt; &lt;/span&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; var imgName = new Array("pica.jpg","picb.jpg","picc.jpg","picd.jpg","pice.jpg","picf.jpg"); var foot = 0; //操作脚标 function setPic() &#123; var img = document.getElementById("img"); img.src = "images/" + imgName[foot ++]; console.log(img.src); if(foot &gt;= imgName.length) &#123; foot = 0; //从0开始 &#125; setTimeout(setPic,1000); //每秒更新一次 &#125; setPic();&lt;/script&gt;&lt;/html&gt; 总结：①所有的事件一定要绑定在它的触发元素上；②静态事件的绑定方式是，在元素上使用“OnXxx”的形式；③每一种事件都一定要捆绑一个函数进行事件的处理。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript（四）事件处理]]></title>
    <url>%2F2018%2F01%2F18%2Fjavascript%EF%BC%88%E5%9B%9B%EF%BC%89%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[javascript事件处理1 .什么是事件，事件驱动，事件处理程序？ 通常鼠标或热键的动作称之为事件； 由鼠标或热键引发的一连串程序的操作，称之为事件驱动； 对事件进行处理程序或函数，称之为事件处理程序。 在页面上任何的操作都可以被称为事件源，而对每一个事件就可以进行自定义的处理方式。如：页面加载，鼠标移动，键盘按下等，都可以称为事件源。 所有的事件在javascript中都是以“onXxx”形式命名。 2 . 下面这两个事件只能在&lt;body&gt;中进行处理： 注：把javascript代码放在&lt;head&gt;&lt;/head&gt;和放在&lt;body&gt;&lt;/body&gt;里是有区别的：放在&lt;head&gt;&lt;/head&gt;里的代码先执行，放在&lt;body&gt;&lt;/body&gt;里的代码后执行。head标签里的代码会在页面还未开始绘制之前被解析，而在body里的代码则会在界面渲染的同时在读取到这段代码的时候才被执行。 页面加载：onload 页面卸载事件：onunload 如下Demo：12345678910111213141516&lt;html&gt; &lt;head&gt; &lt;title&gt;javascript&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;script type="text/javascript"&gt; function loadHandle() &#123; alert("欢迎您的光临！"); &#125; function closeHandle() &#123; alert("感谢您的光临，下次再来哦！"); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body onload="loadHandle();" onunload="closeHandle();"&gt; &lt;/body&gt;&lt;/html&gt; 常用的事件： 3 . 鼠标操作事件 onmousedown（鼠标按下触发） onmouseover（鼠标进入时触发） onmouseout（鼠标移开时触发） onmouseup（鼠标弹开时触发） onmousemove（鼠标移动时触发） 如下Demo1： 123456789101112131415&lt;html&gt; &lt;head&gt; &lt;title&gt;javascript&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;script type="text/javascript"&gt; function mouseHandle() &#123; alert("Hello Mm"); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; //以下为按下时触发，其余的和这个一样 &lt;img src="52.jpeg" height="40%" onmousedown="mouseHandle()"&gt; &lt;/body&gt;&lt;/html&gt; Demo2在按钮上绑定事件（单击）： 1234567891011121314&lt;html&gt; &lt;head&gt; &lt;title&gt;javascript&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;script type="text/javascript"&gt; function clickHandle() &#123; alert("Hello Mm"); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button type="button" onclick="clickHandle()"&gt;按我哦&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 双击将onclick改成ondblclick就可以了。4 . javascript是一个基于对象的编程语言，所有的对象都在元素上，每一个元素（例如：&lt;tr&gt; &lt;td&gt;）都属于一个javascript对象如下Demo： 123456789101112131415161718192021222324252627282930&lt;html&gt; &lt;head&gt; &lt;title&gt;javascript&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;script type="text/javascript"&gt; function Changecolor(obj,color) &#123; obj.bgColor = color; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;table border="1" cellpadding="5" cellspacing="0" bgcolor="#F2F2F2"&gt; &lt;tr onmouseover="Changecolor(this,'white')" onmouseout="Changecolor(this,'#F2F2F2')"&gt; &lt;td&gt;部门编号&lt;/td&gt; &lt;td&gt;部门名称&lt;/td&gt; &lt;td&gt;部门位置&lt;/td&gt; &lt;/tr&gt; &lt;tr onmouseover="Changecolor(this,'white')" onmouseout="Changecolor(this,'#F2F2F2')"&gt; &lt;td&gt;10&lt;/td&gt; &lt;td&gt;财务部&lt;/td&gt; &lt;td&gt;上海&lt;/td&gt; &lt;/tr&gt; &lt;tr onmouseover="Changecolor(this,'white')" onmouseout="Changecolor(this,'#F2F2F2')"&gt; &lt;td&gt;20&lt;/td&gt; &lt;td&gt;技术部&lt;/td&gt; &lt;td&gt;北京&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript（三）定义函数]]></title>
    <url>%2F2018%2F01%2F18%2Fjavascript%EF%BC%88%E4%B8%89%EF%BC%89%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[javascript定义函数1 . javascript中定义函数的操作语法： 123function 函数名称（参数）&#123; return[返回值];&#125; 例子： 123456&lt;script type="text/javascript"&gt; function fun() &#123; alert("Hello World!"); &#125; fun();&lt;/script&gt; 注：函数的重复声明：如果多次采用function命令重复声明同一个函数，则后面的声明会覆盖前面的声明。 1234567891011&lt;script type="text/javascript"&gt; function act() &#123; document.write(1); &#125; act(); document.write("&lt;br&gt;"); function act() &#123; document.write(2); &#125; act();&lt;/script&gt; 2 .javascript模拟面向编程①Demo1: 12345678910&lt;script type="text/javascript"&gt; function Book() &#123; //定义一个Book类 &#125; //prototype属于对原生的操作扩展 Book.prototype.getInfo = function() &#123; return "这是一本书"; &#125; var book = new Book(); alert(book.getInfo());&lt;/script&gt; ②Demo2： 1234567891011&lt;script type="text/javascript"&gt; function Book(title,price) &#123; //定义一个Book类 this.title = title; this.price = price; &#125; Book.prototype.getInfo = function() &#123; return "title=" + this.title + ",price=" + this.price; &#125; var book = new Book("java",34.5); //构造函数 alert(book.getInfo());&lt;/script&gt; ③Demo3： 1234567891011121314&lt;script type="text/javascript"&gt; var myTitle; var myPrice; function Book(title,price) &#123; //定义一个类 myTitle = title; myPrice = price; function getInfo() &#123; return "title=" + myTitle + ",price=" + myPrice; &#125; return getInfo; //返回的是一个函数 &#125; var book = new Book("python",53); //构造函数 alert(book());&lt;/script&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript（二）基本语法]]></title>
    <url>%2F2018%2F01%2F17%2Fjavascript%EF%BC%88%E4%BA%8C%EF%BC%89%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[javascript基本语法 1 . 输出 ① document.write(); 这条语句不可控制元素的顺序。 ② console.log(); 后台输出语句，方便调试2 . 变量①所有的变量只需要一个var关键字②未知状态不赋值的变量-&gt;undefined javascript变量的类型是不确定的： 观察如下小例子： 1234567891011y = 5+5;document.write(y); //结果为：55y = "6"+"6";document.write(y); //结果为：66y = "7"+7;document.write(y); //结果为：77y = 8+"8";document.write(y); //结果为：88 这里看两个demo① 12345678910111213&lt;html&gt; &lt;head&gt; &lt;title&gt;javascript&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;script type="text/javascript"&gt; var num = 10; console.log(typeof num); //注意一下这条语句，控制台输出number类型 &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;你好菲菲！&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; ② 1234567891011121314151617&lt;html&gt; &lt;head&gt; &lt;title&gt;javascript&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;script type="text/javascript"&gt; var num; if(num) &#123; alert("这个变量有内容"); &#125; else &#123; alert("这个变量没有内容"); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;你好菲菲！&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 运行后的结果如下图。因此，如果该变量属于undefined表示else后面的内容，否则属于true，if后面的内容。 类比下面的demo1）将if(num) 改成if(!num) —&gt;输出：“变量有内容”2) 下面的代码弹出的是—&gt;“变量有内容”，改成if(!num)就是“变量没有内容” 1234567891011121314151617&lt;html&gt; &lt;head&gt; &lt;title&gt;javascript&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;script type="text/javascript"&gt; var num = 1; if(num) &#123; alert("这个变量有内容"); &#125; else &#123; alert("这个变量没有内容"); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;你好菲菲！&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 3 . javascript中没有char类型，不管是用单引号’ ‘还是双引号” “都是string类型var num = &#39;a&#39;; var num = &quot;a&quot; 4 . javascript中的截取 1234567891011121314151617&lt;html&gt; &lt;head&gt; &lt;title&gt;javascript&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;script type="text/javascript"&gt; var num = "ni hao shi jie"; var result = num.split(" "); console.log(typeof result); for(var x=0;x&lt;result.length;x++) &#123; console.log(result[x]); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;你好菲菲！&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 5 . 字符串的比较①java中有两种字符串的比较方法：equals()和==②javascript中只提供==这一种方式 12345&lt;script type="text/javascript"&gt; var numa="a"; var numb="a"; console.log(numa==numb); //true&lt;/script&gt; 6 .数组 javascript本身是一个对象的形式出现，所以数组的创建需要使用new关键字 可以这样写：1234var boys = new Array(); boys[0] = "tom" ; boys[1] = "joke" ; body[2] = "Alex" ; 也可以这样： 1var boys = new Array("tom","joke","Alex"); 或者： 1var boys = ["tom","joke","Alex"]; Demo:123456789&lt;script type="text/javascript"&gt; var result = new Array(); result[0] = "hello"; result[1] = 100; result[2] = false; for(var x=0;x&lt;result.length;x++) &#123; console.log(result[x] + "--&gt;" + typeof result[x]); &#125;&lt;/script&gt; javascript中的数组没有长度限制，它提供的就是动态数组。在javascript定义变量的时候可以不使用var，这样定义的变量，以javascript语法来讲就是全局变量，（几乎不使用）即有无var都可以正常使用。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript（一）基本介绍]]></title>
    <url>%2F2018%2F01%2F17%2Fjavascript%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[面向对象和基于对象的区别？ 面向对象强调的是类的设计，对象的调用。 基于对象指的是所有的对象已经由浏览器提供好了，用户直接调用使用就可以了。 Java和JavaScript的区别？ java和javascript没有本质的关系。 java属于面向对象编程，javaScript是一种基于对象的编程语言。 javascript由网景公司开发，java最早由SUN开发。 关于javascript历史 javascript前身是LiveScript，后来网景将其更名为javascript，新的叫法EcmaScript。 EcmaScript是javascript语言的标准，如果把EcmaScript想象成接口，javascript相当于这个接 口的实现类。 注：java前期在浏览器端的发展，主要是Applet程序。 javascript可以做什么？ 可以模拟面向对象编程 可以进行服务器端编程（即Node.JS）。 小知识：Node.JS有两个方向①做网游服务器，②淘宝上一般使用Node.JS。 javascript入门及小Demo javascript是嵌入在HTML语言之中的，使用&lt; script &gt; 标记进行标注。可以实现一系列动态页面的操作效果。 以下为Demo.html 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Javascript&lt;/title&gt; &lt;script type="text/javascript"&gt; alert("Hello World！"); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; ① “text/javascript”代表是javascript语言编写的，也可以更换为VBScript。② 实际开发中javascript的代码是非常多的，很难维护，为了解决这样的问题，往往会单独建立一个*.js的文件，需要的时候导入即可，导入用的是src属性。 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Javascript&lt;/title&gt; &lt;script type="text/javascript" src="js/demo.js" /&gt; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 以下为js文件夹下的demo.js文件的代码 1alert("Hello World！");]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
</search>
